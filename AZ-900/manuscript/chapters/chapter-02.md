# 第 2 章：透視網路傳輸 (Dissecting Network Traffic)

> 「每一筆訂單的背後，都是數百個封包在網路上飛舞。」
> —— CloudMart 技術長，2024 年技術分享會

---

## 本章學習目標

完成本章後，你將能夠：

- 解釋 TCP/IP 協定堆疊的四層架構
- 使用 Wireshark 分析實際的網路封包
- 理解 HTTP 請求與回應的結構
- 說明 TLS/SSL 如何保護網路傳輸安全
- 區分不同 HTTP 方法（GET、POST、PUT、DELETE）的用途
- 解釋三向交握（Three-Way Handshake）的過程

---

## 2.1 CloudMart 的第一筆訂單：封包的旅程

讓我們回到 CloudMart 正式上線的那一天。

2020 年 3 月 15 日，晚上 11:47 分，一位名叫陳小明的顧客正在瀏覽 CloudMart 網站。他看中了一款無線耳機，猶豫了片刻，終於按下了「立即購買」按鈕。

**這個簡單的動作，觸發了什麼？**

```
┌─────────────────────────────────────────────────────────────────┐
│                     一筆訂單的網路旅程                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  陳小明的電腦                                                    │
│  ┌─────────────┐                                                │
│  │  瀏覽器     │                                                │
│  │  Chrome     │                                                │
│  └──────┬──────┘                                                │
│         │ ① 產生 HTTP POST 請求                                 │
│         ▼                                                       │
│  ┌─────────────┐                                                │
│  │  TCP 封裝   │                                                │
│  └──────┬──────┘                                                │
│         │ ② 加上 TCP 標頭（來源埠、目的埠）                       │
│         ▼                                                       │
│  ┌─────────────┐                                                │
│  │  IP 封裝    │                                                │
│  └──────┬──────┘                                                │
│         │ ③ 加上 IP 標頭（來源 IP、目的 IP）                      │
│         ▼                                                       │
│  ┌─────────────┐                                                │
│  │  網路介面   │                                                │
│  │  (Ethernet) │                                                │
│  └──────┬──────┘                                                │
│         │ ④ 加上 MAC 標頭，透過網路線/Wi-Fi 發送                  │
│         │                                                       │
│         ▼                                                       │
│    ═══════════════════════════════════════════════════         │
│         │         網際網路（經過 N 個路由器）                     │
│    ═══════════════════════════════════════════════════         │
│         │                                                       │
│         ▼                                                       │
│  CloudMart 伺服器                                               │
│  ┌─────────────┐                                                │
│  │  反向代理   │ ⑤ 解析封包，將請求轉發到後端                    │
│  │  (Nginx)    │                                                │
│  └──────┬──────┘                                                │
│         ▼                                                       │
│  ┌─────────────┐                                                │
│  │  API 伺服器 │ ⑥ 處理訂單邏輯                                  │
│  │  (Node.js)  │                                                │
│  └──────┬──────┘                                                │
│         ▼                                                       │
│  ┌─────────────┐                                                │
│  │  資料庫     │ ⑦ 寫入訂單資料                                  │
│  │ (PostgreSQL)│                                                │
│  └─────────────┘                                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

這一連串的過程，從按下按鈕到看到「訂單成功」的畫面，只花了 0.3 秒。

但在這 0.3 秒內，發生了超過 50 個網路封包的交換。

讓我們拆解這個過程。

---

## 2.2 TCP/IP 協定堆疊：網路的骨架

### 2.2.1 為什麼需要分層？

想像你要寄一封國際郵件：

1. 你寫好信的內容（應用層）
2. 把信裝進信封，貼上地址（傳輸層）
3. 郵局在信封上蓋上郵戳，放進郵袋（網際網路層）
4. 郵差騎車把郵袋送到下一站（網路存取層）

每一層只負責自己的工作，不需要知道其他層的細節。這就是**分層架構**的優點。

### 2.2.2 TCP/IP 四層模型

```
┌─────────────────────────────────────────────────────────────────┐
│                     TCP/IP 協定堆疊                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    應用層                                │   │
│  │               Application Layer                         │   │
│  │                                                         │   │
│  │   協定：HTTP, HTTPS, FTP, SMTP, DNS, SSH                │   │
│  │   功能：提供使用者應用程式的網路服務                      │   │
│  │   範例：瀏覽器、電子郵件客戶端、FTP 軟體                  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                    │
│                           ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    傳輸層                                │   │
│  │                Transport Layer                          │   │
│  │                                                         │   │
│  │   協定：TCP, UDP                                         │   │
│  │   功能：端對端的資料傳輸、流量控制、錯誤檢測              │   │
│  │   範例：確保資料完整送達（TCP）或快速傳輸（UDP）          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                    │
│                           ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   網際網路層                             │   │
│  │                 Internet Layer                          │   │
│  │                                                         │   │
│  │   協定：IP, ICMP, ARP                                    │   │
│  │   功能：定址、路由、封包分割與重組                        │   │
│  │   範例：決定封包要走哪條路到達目的地                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                    │
│                           ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   網路存取層                             │   │
│  │              Network Access Layer                       │   │
│  │                                                         │   │
│  │   協定：Ethernet, Wi-Fi (802.11), PPP                   │   │
│  │   功能：在實體媒介上傳輸資料框架                          │   │
│  │   範例：網路線、Wi-Fi 訊號、光纖                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2.3 封裝與解封裝

當資料從應用層向下傳遞時，每一層都會加上自己的「標頭」（Header），這個過程叫做**封裝（Encapsulation）**。

```
┌─────────────────────────────────────────────────────────────────┐
│                       資料封裝過程                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  應用層產生的資料                                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              HTTP POST /api/orders                      │   │
│  │              {"product": "耳機", "qty": 1}              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                           │                                    │
│                           ▼ 加上 TCP 標頭                       │
│  ┌──────────┬──────────────────────────────────────────────┐   │
│  │TCP Header│              HTTP 資料                       │   │
│  │Src:52341 │              {...}                           │   │
│  │Dst:443   │                                              │   │
│  └──────────┴──────────────────────────────────────────────┘   │
│                           │                                    │
│                           ▼ 加上 IP 標頭                        │
│  ┌──────────┬──────────┬───────────────────────────────────┐   │
│  │IP Header │TCP Header│              HTTP 資料            │   │
│  │Src:      │          │              {...}                │   │
│  │192.168.  │          │                                   │   │
│  │1.100     │          │                                   │   │
│  │Dst:      │          │                                   │   │
│  │20.43.    │          │                                   │   │
│  │161.50    │          │                                   │   │
│  └──────────┴──────────┴───────────────────────────────────┘   │
│                           │                                    │
│                           ▼ 加上 Ethernet 標頭與尾部             │
│  ┌──────────┬──────────┬──────────┬────────────────┬───────┐   │
│  │Eth Header│IP Header │TCP Header│   HTTP 資料    │Eth FCS│   │
│  │MAC 位址  │          │          │                │校驗碼 │   │
│  └──────────┴──────────┴──────────┴────────────────┴───────┘   │
│                                                                 │
│  這個完整的結構稱為「訊框」（Frame）                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.3 IP 位址與連接埠：網路上的門牌號碼

### 2.3.1 IP 位址

IP 位址就像是網路上的「門牌號碼」，用來識別每一台設備。

**IPv4 位址格式：**

```
192.168.1.100
 │   │   │  │
 │   │   │  └── 0-255（主機識別碼）
 │   │   └───── 0-255
 │   └───────── 0-255
 └───────────── 0-255（網路識別碼）

總共 32 位元，可表示約 43 億個位址
```

**公有 IP vs. 私有 IP：**

| 類型 | 範圍 | 用途 |
|------|------|------|
| 公有 IP | 除了私有 IP 以外的所有位址 | 網際網路上的唯一識別 |
| 私有 IP (Class A) | 10.0.0.0 - 10.255.255.255 | 大型企業內部網路 |
| 私有 IP (Class B) | 172.16.0.0 - 172.31.255.255 | 中型企業內部網路 |
| 私有 IP (Class C) | 192.168.0.0 - 192.168.255.255 | 家庭、小型企業 |

**CloudMart 的 IP 配置：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    CloudMart 網路架構                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  網際網路                                                        │
│      │                                                          │
│      │ 公有 IP: 20.43.161.50                                    │
│      ▼                                                          │
│  ┌─────────────────┐                                            │
│  │  Azure 負載平衡  │                                            │
│  │  Load Balancer  │                                            │
│  └────────┬────────┘                                            │
│           │                                                     │
│           │ 私有 IP 網段: 10.0.0.0/16                            │
│           │                                                     │
│  ┌────────┴────────────────────────────────────────────┐       │
│  │                                                      │       │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │       │
│  │  │ Web-01   │  │ Web-02   │  │ Web-03   │          │       │
│  │  │10.0.1.10 │  │10.0.1.11 │  │10.0.1.12 │          │       │
│  │  └──────────┘  └──────────┘  └──────────┘          │       │
│  │                                                      │       │
│  │  ┌──────────┐  ┌──────────┐                         │       │
│  │  │ API-01   │  │ API-02   │                         │       │
│  │  │10.0.2.10 │  │10.0.2.11 │                         │       │
│  │  └──────────┘  └──────────┘                         │       │
│  │                                                      │       │
│  │  ┌──────────────────────────┐                       │       │
│  │  │      Database            │                       │       │
│  │  │      10.0.3.10           │                       │       │
│  │  └──────────────────────────┘                       │       │
│  │                                                      │       │
│  │         Azure Virtual Network                        │       │
│  └──────────────────────────────────────────────────────┘       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3.2 連接埠（Port）

如果 IP 位址是「門牌號碼」，那麼連接埠就是「房間號碼」。

一台伺服器可能同時運行多個服務，連接埠用來區分不同的服務。

**常用連接埠：**

| 連接埠 | 服務 | 說明 |
|--------|------|------|
| 20, 21 | FTP | 檔案傳輸 |
| 22 | SSH | 安全遠端登入 |
| 23 | Telnet | 遠端登入（不安全） |
| 25 | SMTP | 郵件發送 |
| 53 | DNS | 網域名稱解析 |
| 80 | HTTP | 網頁服務（未加密） |
| 443 | HTTPS | 網頁服務（加密） |
| 3306 | MySQL | MySQL 資料庫 |
| 5432 | PostgreSQL | PostgreSQL 資料庫 |
| 6379 | Redis | Redis 快取 |

**連接埠範圍：**

| 範圍 | 名稱 | 說明 |
|------|------|------|
| 0-1023 | 知名連接埠 | 保留給標準服務（需要 root 權限） |
| 1024-49151 | 註冊連接埠 | 可由應用程式註冊使用 |
| 49152-65535 | 動態連接埠 | 客戶端臨時使用 |

### 2.3.3 Socket：IP + Port 的組合

**Socket**（套接字）是 IP 位址和連接埠的組合，用來唯一識別一個網路連線。

```
客戶端 Socket: 192.168.1.100:52341
                    │         │
                    │         └── 隨機分配的動態連接埠
                    └──────────── 客戶端 IP

伺服器 Socket: 20.43.161.50:443
                    │        │
                    │        └── HTTPS 服務連接埠
                    └─────────── 伺服器公有 IP

完整的連線可以用這對 Socket 來識別：
(192.168.1.100:52341) ←→ (20.43.161.50:443)
```

---

## 2.4 TCP：可靠的傳輸協定

### 2.4.1 為什麼需要 TCP？

IP 協定只負責把封包「盡力送達」（Best Effort），但它：

- 不保證封包一定會到達
- 不保證封包按順序到達
- 不保證封包不會重複

**TCP（Transmission Control Protocol）** 在 IP 之上提供：

- ✅ 可靠傳輸（遺失的封包會重傳）
- ✅ 有序傳輸（封包按順序重組）
- ✅ 流量控制（不會塞爆接收方）
- ✅ 壅塞控制（不會塞爆網路）

### 2.4.2 三向交握（Three-Way Handshake）

在傳輸資料之前，TCP 必須先建立連線。這個過程需要三次封包交換，稱為「三向交握」。

```
┌─────────────────────────────────────────────────────────────────┐
│                     TCP 三向交握                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   客戶端                                          伺服器        │
│   (陳小明的電腦)                              (CloudMart)       │
│                                                                 │
│       │                                            │            │
│       │  ① SYN (seq=100)                          │            │
│       │  "嘿，我想建立連線"                         │            │
│       │ ─────────────────────────────────────────► │            │
│       │                                            │            │
│       │  ② SYN-ACK (seq=300, ack=101)             │            │
│       │  "好的，我收到了，我也想建立連線"           │            │
│       │ ◄───────────────────────────────────────── │            │
│       │                                            │            │
│       │  ③ ACK (seq=101, ack=301)                 │            │
│       │  "收到，連線建立完成！"                     │            │
│       │ ─────────────────────────────────────────► │            │
│       │                                            │            │
│       │  ═══════════ 連線已建立 ═══════════        │            │
│       │                                            │            │
│       │  ④ 開始傳輸 HTTP 請求資料                   │            │
│       │ ═════════════════════════════════════════► │            │
│       │                                            │            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**為什麼要三次？**

- **第一次（SYN）**：客戶端確認自己能發送
- **第二次（SYN-ACK）**：伺服器確認能收到客戶端的訊息，也能發送給客戶端
- **第三次（ACK）**：客戶端確認能收到伺服器的訊息

只有兩次握手的話，伺服器無法確認客戶端能收到它的回應。

### 2.4.3 TCP 標頭結構

```
┌─────────────────────────────────────────────────────────────────┐
│                       TCP 標頭（20 位元組）                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   0                   1                   2                   3 │
│   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1│
│  ┌───────────────────────────┬───────────────────────────────┐  │
│  │       來源連接埠 (16位元)  │      目的連接埠 (16位元)       │  │
│  │       Source Port         │      Destination Port         │  │
│  ├───────────────────────────┴───────────────────────────────┤  │
│  │                    序號 Sequence Number (32位元)           │  │
│  ├───────────────────────────────────────────────────────────┤  │
│  │               確認號 Acknowledgment Number (32位元)        │  │
│  ├───────┬───────┬───────────┬───────────────────────────────┤  │
│  │ 資料  │ 保留  │  旗標     │         視窗大小              │  │
│  │ 偏移  │ (6位) │URG|ACK|PSH│       Window Size             │  │
│  │ (4位) │       │RST|SYN|FIN│         (16位元)              │  │
│  ├───────┴───────┴───────────┼───────────────────────────────┤  │
│  │       檢查碼 Checksum     │      緊急指標 Urgent Pointer  │  │
│  │         (16位元)          │         (16位元)              │  │
│  ├───────────────────────────┴───────────────────────────────┤  │
│  │                    選項 Options（可變長度）                │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  重要旗標說明：                                                  │
│  • SYN：同步，用於建立連線                                       │
│  • ACK：確認，表示確認號有效                                     │
│  • FIN：結束，用於關閉連線                                       │
│  • RST：重置，強制關閉連線                                       │
│  • PSH：推送，要求立即傳送資料                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.4.4 四向揮手（Four-Way Handshake）

當資料傳輸完成，需要關閉連線：

```
┌─────────────────────────────────────────────────────────────────┐
│                     TCP 四向揮手                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   客戶端                                          伺服器        │
│                                                                 │
│       │                                            │            │
│       │  ① FIN (seq=500)                          │            │
│       │  "我這邊資料傳完了，要關閉連線"             │            │
│       │ ─────────────────────────────────────────► │            │
│       │                                            │            │
│       │  ② ACK (ack=501)                          │            │
│       │  "好的，我知道了"                          │            │
│       │ ◄───────────────────────────────────────── │            │
│       │                                            │            │
│       │  （伺服器可能還有資料要傳）                  │            │
│       │                                            │            │
│       │  ③ FIN (seq=700)                          │            │
│       │  "我這邊也傳完了，可以關閉了"               │            │
│       │ ◄───────────────────────────────────────── │            │
│       │                                            │            │
│       │  ④ ACK (ack=701)                          │            │
│       │  "收到，再見！"                            │            │
│       │ ─────────────────────────────────────────► │            │
│       │                                            │            │
│       │  ═══════════ 連線已關閉 ═══════════        │            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2.5 HTTP 協定：網頁的語言

### 2.5.1 什麼是 HTTP？

**HTTP（HyperText Transfer Protocol）** 是用於網頁傳輸的應用層協定。

每當你瀏覽網頁、提交表單、下載檔案，都是透過 HTTP 進行的。

### 2.5.2 HTTP 請求結構

```
┌─────────────────────────────────────────────────────────────────┐
│                     HTTP 請求結構                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  POST /api/orders HTTP/1.1                    ◄── 請求行        │
│  Host: api.cloudmart.com                      ◄── 標頭開始      │
│  Content-Type: application/json                                 │
│  Authorization: Bearer eyJhbGciOiJIUzI1NiIs...                  │
│  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)         │
│  Accept: application/json                                       │
│  Content-Length: 127                          ◄── 標頭結束      │
│                                               ◄── 空行（分隔）   │
│  {                                            ◄── 請求主體開始  │
│    "product_id": "HEADPHONE-001",                               │
│    "quantity": 1,                                               │
│    "shipping_address": {                                        │
│      "city": "台北市",                                          │
│      "district": "信義區"                                       │
│    }                                                            │
│  }                                            ◄── 請求主體結束  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**請求行的組成：**

```
POST        /api/orders      HTTP/1.1
 │              │               │
 │              │               └── 協定版本
 │              └────────────────── 資源路徑（URI）
 └───────────────────────────────── HTTP 方法
```

### 2.5.3 HTTP 方法

| 方法 | 用途 | 是否有主體 | 是否冪等 | CloudMart 範例 |
|------|------|-----------|---------|---------------|
| **GET** | 讀取資源 | 否 | 是 | 取得商品列表 |
| **POST** | 建立資源 | 是 | 否 | 建立新訂單 |
| **PUT** | 完整更新資源 | 是 | 是 | 更新整個商品資訊 |
| **PATCH** | 部分更新資源 | 是 | 否 | 只更新商品價格 |
| **DELETE** | 刪除資源 | 否 | 是 | 刪除購物車項目 |
| **HEAD** | 取得標頭（不要主體） | 否 | 是 | 檢查資源是否存在 |
| **OPTIONS** | 查詢支援的方法 | 否 | 是 | CORS 預檢請求 |

**冪等性（Idempotent）是什麼意思？**

> 同一個請求執行一次和執行多次，結果是一樣的。

```
# GET 是冪等的
GET /products/123    # 第一次：回傳商品資訊
GET /products/123    # 第二次：還是回傳相同的商品資訊

# POST 不是冪等的
POST /orders         # 第一次：建立訂單 #1001
POST /orders         # 第二次：又建立了訂單 #1002（不一樣！）

# DELETE 是冪等的
DELETE /cart/item/5  # 第一次：刪除項目，回傳 200 OK
DELETE /cart/item/5  # 第二次：項目已不存在，回傳 404（結果一樣是「項目不在了」）
```

### 2.5.4 HTTP 回應結構

```
┌─────────────────────────────────────────────────────────────────┐
│                     HTTP 回應結構                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  HTTP/1.1 201 Created                         ◄── 狀態行        │
│  Content-Type: application/json               ◄── 標頭開始      │
│  X-Request-Id: abc123                                           │
│  Date: Mon, 15 Mar 2024 15:47:32 GMT                            │
│  Content-Length: 245                          ◄── 標頭結束      │
│                                               ◄── 空行          │
│  {                                            ◄── 回應主體開始  │
│    "order_id": "ORD-20240315-001",                              │
│    "status": "pending",                                         │
│    "total": 2990,                                               │
│    "created_at": "2024-03-15T15:47:32Z",                        │
│    "message": "訂單建立成功"                                     │
│  }                                            ◄── 回應主體結束  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.5.5 HTTP 狀態碼

| 範圍 | 類別 | 常見狀態碼 | 說明 |
|------|------|-----------|------|
| **1xx** | 資訊回應 | 100 Continue | 繼續發送請求主體 |
| **2xx** | 成功 | 200 OK | 請求成功 |
|         |       | 201 Created | 資源建立成功 |
|         |       | 204 No Content | 成功但無內容回傳 |
| **3xx** | 重新導向 | 301 Moved Permanently | 永久轉址 |
|         |          | 302 Found | 暫時轉址 |
|         |          | 304 Not Modified | 使用快取 |
| **4xx** | 客戶端錯誤 | 400 Bad Request | 請求格式錯誤 |
|         |           | 401 Unauthorized | 未認證 |
|         |           | 403 Forbidden | 無權限 |
|         |           | 404 Not Found | 資源不存在 |
|         |           | 429 Too Many Requests | 請求過於頻繁 |
| **5xx** | 伺服器錯誤 | 500 Internal Server Error | 伺服器內部錯誤 |
|         |           | 502 Bad Gateway | 閘道錯誤 |
|         |           | 503 Service Unavailable | 服務暫時不可用 |
|         |           | 504 Gateway Timeout | 閘道逾時 |

**CloudMart 常見的錯誤處理：**

```javascript
// CloudMart API 錯誤回應範例
// 400 Bad Request
{
  "error": "VALIDATION_ERROR",
  "message": "商品數量必須大於 0",
  "field": "quantity",
  "received_value": -1
}

// 401 Unauthorized
{
  "error": "AUTHENTICATION_REQUIRED",
  "message": "請先登入"
}

// 404 Not Found
{
  "error": "PRODUCT_NOT_FOUND",
  "message": "找不到指定的商品",
  "product_id": "HEADPHONE-999"
}

// 500 Internal Server Error
{
  "error": "INTERNAL_ERROR",
  "message": "系統發生錯誤，請稍後再試",
  "request_id": "abc123"  // 用於追蹤問題
}
```

---

## 2.6 HTTPS 與 TLS：保護你的資料

### 2.6.1 HTTP 的安全問題

純粹的 HTTP 傳輸是「明文」的，任何人都可以在傳輸途中看到內容：

```
┌─────────────────────────────────────────────────────────────────┐
│                     HTTP 的安全風險                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   陳小明                     駭客                    CloudMart  │
│     │                         │                         │      │
│     │   POST /api/login       │                         │      │
│     │   {"password":"123456"} │                         │      │
│     │ ───────────────────────►│ 攔截！看到密碼了！      │      │
│     │                         │─────────────────────────►│     │
│     │                         │                         │      │
│     │◄────────────────────────────────────────────────── │      │
│     │                         │                         │      │
│                                                                 │
│   風險：                                                         │
│   1. 竊聽（Eavesdropping）：讀取傳輸中的敏感資料                  │
│   2. 竄改（Tampering）：修改傳輸中的資料                          │
│   3. 冒充（Impersonation）：假冒 CloudMart 網站                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.6.2 HTTPS = HTTP + TLS

**HTTPS** 在 HTTP 之下加入了 **TLS（Transport Layer Security）** 加密層。

```
┌─────────────────────────────────────────────────────────────────┐
│                    HTTP vs HTTPS 協定堆疊                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│        HTTP                           HTTPS                     │
│                                                                 │
│   ┌───────────────┐              ┌───────────────┐             │
│   │     HTTP      │              │     HTTP      │             │
│   ├───────────────┤              ├───────────────┤             │
│   │               │              │     TLS       │ ◄── 加密層  │
│   │               │              ├───────────────┤             │
│   │     TCP       │              │     TCP       │             │
│   ├───────────────┤              ├───────────────┤             │
│   │     IP        │              │     IP        │             │
│   └───────────────┘              └───────────────┘             │
│                                                                 │
│   連接埠：80                      連接埠：443                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.6.3 TLS 握手過程

在傳輸加密資料之前，客戶端和伺服器需要先協商加密方式。這個過程稱為「TLS 握手」。

```
┌─────────────────────────────────────────────────────────────────┐
│                     TLS 握手過程（簡化版）                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   客戶端                                          伺服器        │
│                                                                 │
│       │  ① Client Hello                           │            │
│       │  • 支援的 TLS 版本                         │            │
│       │  • 支援的加密套件                          │            │
│       │  • 隨機數 (Client Random)                 │            │
│       │ ─────────────────────────────────────────► │            │
│       │                                            │            │
│       │  ② Server Hello                           │            │
│       │  • 選定的 TLS 版本                         │            │
│       │  • 選定的加密套件                          │            │
│       │  • 隨機數 (Server Random)                 │            │
│       │  • 伺服器憑證 (Certificate)               │            │
│       │ ◄───────────────────────────────────────── │            │
│       │                                            │            │
│       │  ③ 客戶端驗證憑證                          │            │
│       │  • 檢查憑證是否由可信任的 CA 簽發           │            │
│       │  • 檢查憑證是否過期                         │            │
│       │  • 檢查域名是否匹配                         │            │
│       │                                            │            │
│       │  ④ Key Exchange                           │            │
│       │  • 產生 Pre-Master Secret                 │            │
│       │  • 用伺服器公鑰加密後傳送                  │            │
│       │ ─────────────────────────────────────────► │            │
│       │                                            │            │
│       │  ⑤ 雙方各自計算 Session Key               │            │
│       │  Session Key = f(Client Random,           │            │
│       │                  Server Random,           │            │
│       │                  Pre-Master Secret)       │            │
│       │                                            │            │
│       │  ⑥ Finished (已加密)                      │            │
│       │ ◄──────────────────────────────────────────►           │
│       │                                            │            │
│       │  ═══════════ 加密通道建立 ═══════════      │            │
│       │                                            │            │
│       │  ⑦ 開始傳輸加密的 HTTP 資料                │            │
│       │ ═══════════════════════════════════════════►           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.6.4 憑證（Certificate）的作用

**為什麼需要憑證？**

> 憑證就像是伺服器的「身分證」，由可信任的第三方（CA, Certificate Authority）簽發。

```
┌─────────────────────────────────────────────────────────────────┐
│                     SSL/TLS 憑證結構                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │                    憑證內容                                │ │
│  ├───────────────────────────────────────────────────────────┤ │
│  │                                                           │ │
│  │  Subject (主體)                                           │ │
│  │  ├── Common Name: *.cloudmart.com                        │ │
│  │  ├── Organization: CloudMart Inc.                        │ │
│  │  └── Country: TW                                         │ │
│  │                                                           │ │
│  │  Issuer (簽發者)                                          │ │
│  │  ├── Common Name: DigiCert Global Root CA                │ │
│  │  └── Organization: DigiCert Inc.                         │ │
│  │                                                           │ │
│  │  Validity (有效期)                                        │ │
│  │  ├── Not Before: 2024-01-01 00:00:00 UTC                 │ │
│  │  └── Not After:  2025-01-01 00:00:00 UTC                 │ │
│  │                                                           │ │
│  │  Public Key (公鑰)                                        │ │
│  │  └── RSA 2048 bits                                       │ │
│  │                                                           │ │
│  │  Extensions                                               │ │
│  │  └── Subject Alternative Names:                          │ │
│  │      - *.cloudmart.com                                   │ │
│  │      - cloudmart.com                                     │ │
│  │      - api.cloudmart.com                                 │ │
│  │                                                           │ │
│  ├───────────────────────────────────────────────────────────┤ │
│  │  Signature (數位簽章)                                     │ │
│  │  └── 由 DigiCert 私鑰簽署，證明此憑證真實性               │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**憑證信任鏈：**

```
┌───────────────────┐
│   Root CA         │ ◄── 預先安裝在作業系統/瀏覽器中
│  (DigiCert Root)  │
└────────┬──────────┘
         │ 簽發
         ▼
┌───────────────────┐
│  Intermediate CA  │ ◄── 中繼憑證
│  (DigiCert TLS)   │
└────────┬──────────┘
         │ 簽發
         ▼
┌───────────────────┐
│   End Entity      │ ◄── 網站憑證
│ (cloudmart.com)   │
└───────────────────┘
```

### 2.6.5 CloudMart 的 HTTPS 設定

```nginx
# CloudMart Nginx SSL 設定
server {
    listen 443 ssl http2;
    server_name cloudmart.com www.cloudmart.com;

    # 憑證檔案
    ssl_certificate     /etc/letsencrypt/live/cloudmart.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/cloudmart.com/privkey.pem;

    # TLS 設定
    ssl_protocols TLSv1.2 TLSv1.3;  # 只允許較新的協定
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    ssl_prefer_server_ciphers on;

    # HSTS（強制使用 HTTPS）
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # OCSP Stapling（加速憑證驗證）
    ssl_stapling on;
    ssl_stapling_verify on;

    location / {
        proxy_pass http://backend;
    }
}

# HTTP 轉 HTTPS
server {
    listen 80;
    server_name cloudmart.com www.cloudmart.com;
    return 301 https://$server_name$request_uri;
}
```

---

## 2.7 動手實作：使用 Wireshark 分析封包

### 2.7.1 安裝 Wireshark

```bash
# macOS
brew install --cask wireshark

# Windows
# 從 https://www.wireshark.org/download.html 下載安裝

# Linux (Ubuntu/Debian)
sudo apt install wireshark
```

### 2.7.2 擷取 HTTP 請求

讓我們實際擷取一個 HTTP 請求來觀察：

1. 開啟 Wireshark
2. 選擇你正在使用的網路介面（如 Wi-Fi 或乙太網路）
3. 在過濾器輸入：`http`
4. 開始擷取
5. 在瀏覽器中打開一個 HTTP 網站（注意：不是 HTTPS）

**擷取到的封包範例：**

```
Frame 1: 342 bytes on wire
Ethernet II, Src: Apple_xx:xx:xx, Dst: Router_yy:yy:yy
Internet Protocol Version 4, Src: 192.168.1.100, Dst: 93.184.216.34
Transmission Control Protocol, Src Port: 52341, Dst Port: 80
    Source Port: 52341
    Destination Port: 80
    Sequence Number: 1
    Acknowledgment Number: 1
    Flags: 0x018 (PSH, ACK)
Hypertext Transfer Protocol
    GET /index.html HTTP/1.1\r\n
    Host: example.com\r\n
    User-Agent: Mozilla/5.0 ...\r\n
    Accept: text/html,application/xhtml+xml\r\n
    Accept-Language: zh-TW,zh;q=0.9,en;q=0.8\r\n
    Accept-Encoding: gzip, deflate\r\n
    Connection: keep-alive\r\n
    \r\n
```

### 2.7.3 觀察 TCP 三向交握

使用過濾器：`tcp.flags.syn==1 || tcp.flags.ack==1`

你會看到類似這樣的封包序列：

```
No.  Time     Source          Destination     Protocol  Info
1    0.000    192.168.1.100   93.184.216.34   TCP       52341→80 [SYN]
2    0.025    93.184.216.34   192.168.1.100   TCP       80→52341 [SYN, ACK]
3    0.026    192.168.1.100   93.184.216.34   TCP       52341→80 [ACK]
4    0.027    192.168.1.100   93.184.216.34   HTTP      GET /index.html
```

### 2.7.4 觀察 TLS 握手

使用過濾器：`tls.handshake`

```
No.  Time     Source          Destination     Protocol  Info
1    0.000    192.168.1.100   20.43.161.50    TLSv1.3   Client Hello
2    0.035    20.43.161.50    192.168.1.100   TLSv1.3   Server Hello, Certificate
3    0.036    192.168.1.100   20.43.161.50    TLSv1.3   Key Exchange, Finished
4    0.071    20.43.161.50    192.168.1.100   TLSv1.3   Finished
5    0.072    192.168.1.100   20.43.161.50    TLSv1.3   Application Data (加密)
```

注意：使用 HTTPS 時，你只能看到 TLS 握手過程，實際的 HTTP 內容是加密的。

---

## 2.8 實戰練習：建立一個簡單的 HTTP 伺服器

讓我們用 Python 建立一個簡單的 HTTP 伺服器，來理解 HTTP 的運作：

```python
# simple_http_server.py
# CloudMart 最簡 API 伺服器範例

from http.server import HTTPServer, BaseHTTPRequestHandler
import json

class CloudMartHandler(BaseHTTPRequestHandler):
    """
    處理 CloudMart API 請求的 Handler
    """

    # 模擬的商品資料庫
    products = {
        "HEADPHONE-001": {
            "id": "HEADPHONE-001",
            "name": "無線降噪耳機",
            "price": 2990,
            "stock": 50
        },
        "KEYBOARD-001": {
            "id": "KEYBOARD-001",
            "name": "機械鍵盤",
            "price": 3500,
            "stock": 30
        }
    }

    def do_GET(self):
        """處理 GET 請求"""
        if self.path == "/api/products":
            # 回傳所有商品
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            response = json.dumps(list(self.products.values()), ensure_ascii=False)
            self.wfile.write(response.encode("utf-8"))

        elif self.path.startswith("/api/products/"):
            # 回傳單一商品
            product_id = self.path.split("/")[-1]
            if product_id in self.products:
                self.send_response(200)
                self.send_header("Content-Type", "application/json")
                self.end_headers()
                response = json.dumps(self.products[product_id], ensure_ascii=False)
                self.wfile.write(response.encode("utf-8"))
            else:
                self.send_error(404, "Product not found")
        else:
            self.send_error(404, "Not found")

    def do_POST(self):
        """處理 POST 請求"""
        if self.path == "/api/orders":
            # 建立訂單
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length).decode("utf-8")

            try:
                order_data = json.loads(body)
                # 模擬建立訂單
                response = {
                    "order_id": "ORD-2024-001",
                    "status": "created",
                    "items": order_data,
                    "message": "訂單建立成功"
                }
                self.send_response(201)
                self.send_header("Content-Type", "application/json")
                self.end_headers()
                self.wfile.write(json.dumps(response, ensure_ascii=False).encode("utf-8"))
            except json.JSONDecodeError:
                self.send_error(400, "Invalid JSON")
        else:
            self.send_error(404, "Not found")

def run_server(port=8080):
    """啟動伺服器"""
    server_address = ("", port)
    httpd = HTTPServer(server_address, CloudMartHandler)
    print(f"CloudMart API 伺服器啟動於 http://localhost:{port}")
    print("按 Ctrl+C 停止")
    httpd.serve_forever()

if __name__ == "__main__":
    run_server()
```

**測試 API：**

```bash
# 啟動伺服器
python simple_http_server.py

# 另開終端機測試

# GET 請求 - 取得所有商品
curl http://localhost:8080/api/products

# GET 請求 - 取得單一商品
curl http://localhost:8080/api/products/HEADPHONE-001

# POST 請求 - 建立訂單
curl -X POST http://localhost:8080/api/orders \
     -H "Content-Type: application/json" \
     -d '{"product_id": "HEADPHONE-001", "quantity": 1}'
```

---

## 2.9 章節總結

### 核心概念回顧

| 概念 | 說明 | 重要性 |
|------|------|--------|
| **TCP/IP 四層模型** | 網路通訊的分層架構 | 理解網路運作的基礎 |
| **IP 位址** | 網路上的唯一識別 | 每台設備都需要 |
| **連接埠** | 區分不同服務 | 80=HTTP, 443=HTTPS |
| **TCP 三向交握** | 建立可靠連線 | 確保通訊雙方都準備好 |
| **HTTP 方法** | GET, POST, PUT, DELETE | RESTful API 的基礎 |
| **HTTP 狀態碼** | 200, 404, 500 等 | 了解請求結果 |
| **TLS/SSL** | 加密傳輸 | 保護敏感資料 |
| **憑證** | 伺服器身分證明 | 防止中間人攻擊 |

### AZ-900 考試重點

1. **網路基礎**：了解 TCP/IP、IP 位址、子網路
2. **HTTP/HTTPS**：知道兩者的差異以及為何 HTTPS 重要
3. **連接埠**：知道常用服務的預設連接埠
4. **安全傳輸**：理解 TLS 如何保護資料

### 學習檢查清單

完成本章後，請確認你可以：

- [ ] 說明 TCP/IP 四層模型的每一層功能
- [ ] 解釋公有 IP 和私有 IP 的差異
- [ ] 描述 TCP 三向交握的過程
- [ ] 區分不同 HTTP 方法的用途
- [ ] 解釋常見 HTTP 狀態碼的意義
- [ ] 說明 HTTPS 如何保護傳輸安全
- [ ] 使用 Wireshark 擷取並分析封包
- [ ] 建立簡單的 HTTP 伺服器

---

## 2.10 下一章預告

在下一章「連接世界的大門」中，我們將探討：

- 當用戶輸入 `www.cloudmart.com` 時，DNS 如何找到伺服器 IP？
- 如何使用 CDN 加速全球用戶的存取？
- 防火牆如何保護 CloudMart 不受惡意攻擊？
- CORS 是什麼？為什麼前端工程師常常被它困擾？

這些知識將幫助你理解 CloudMart 如何服務全球客戶並保障系統安全。

---

## 延伸閱讀

- [RFC 793: Transmission Control Protocol](https://tools.ietf.org/html/rfc793)
- [RFC 2616: HTTP/1.1](https://tools.ietf.org/html/rfc2616)
- [RFC 8446: TLS 1.3](https://tools.ietf.org/html/rfc8446)
- [Wireshark 官方文件](https://www.wireshark.org/docs/)

---

**上一章：[第 1 章：雲端運算的演進](./chapter-01.md)**

**下一章：[第 3 章：連接世界的大門](./chapter-03.md)**
