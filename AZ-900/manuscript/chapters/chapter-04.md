# 第 4 章：解構單體架構 (Breaking the Monolith)

> 「我們的程式碼像一碗義大利麵——每次修改一個功能，都會影響其他十個地方。」
> —— CloudMart 資深工程師，2023 年年度回顧

---

## 本章學習目標

完成本章後，你將能夠：

- 解釋單體架構與微服務架構的差異
- 識別單體應用的常見問題
- 理解容器化技術的核心概念
- 使用 Docker 將應用程式容器化
- 說明 Kubernetes 的基本架構
- 在 Azure 上部署容器化應用程式

---

## 4.1 黑色星期五的崩潰

2022 年 11 月 25 日，黑色星期五。

凌晨 00:00，促銷活動正式開始。CloudMart 的技術團隊緊盯著監控儀表板。

00:05 — 一切正常，每秒 500 個請求。

00:15 — 流量開始攀升，每秒 2,000 個請求。伺服器 CPU 使用率 60%。

00:30 — 每秒 5,000 個請求。CPU 使用率 85%。資料庫連線池開始告警。

00:45 — 每秒 8,000 個請求。第一台伺服器開始回應變慢。

01:00 — **系統崩潰。**

```
┌─────────────────────────────────────────────────────────────────┐
│                     崩潰時序圖                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  時間    事件                          影響                      │
│  ─────────────────────────────────────────────────────────────  │
│  00:45   商品搜尋模組 CPU 100%         搜尋功能變慢              │
│          ↓                                                      │
│  00:48   搜尋變慢導致用戶重複點擊      請求量倍增                 │
│          ↓                                                      │
│  00:52   資料庫連線池耗盡              所有需要 DB 的功能阻塞     │
│          ↓                                                      │
│  00:55   記憶體使用量飆升              垃圾回收開始頻繁觸發       │
│          ↓                                                      │
│  00:58   GC 暫停時間過長               請求開始逾時              │
│          ↓                                                      │
│  01:00   應用程式完全無回應            整個網站下線              │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │                    損失統計                                │ │
│  │                                                           │ │
│  │  停機時間：2 小時 15 分鐘                                  │ │
│  │  損失訂單：約 8,500 筆                                     │ │
│  │  預估營收損失：NT$ 25,000,000                             │ │
│  │  客戶投訴：1,247 件                                       │ │
│  │  社群媒體負評：大量                                        │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

事後檢討會議上，團隊分析了問題的根本原因：

**CloudMart 是一個典型的「單體應用」。**

---

## 4.2 單體架構：一體成形的巨石

### 4.2.1 什麼是單體架構？

**單體架構（Monolithic Architecture）** 是傳統的軟體架構模式，所有功能模組都打包在一個應用程式中。

```
┌─────────────────────────────────────────────────────────────────┐
│                   CloudMart 單體架構                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    ┌─────────────────────────────────────────┐  │
│                    │           CloudMart 應用程式             │  │
│                    │                                         │  │
│  ┌─────────────────┼─────────────────────────────────────────┼─┐│
│  │                 │                                         │ ││
│  │  ┌───────────┐  │  ┌───────────┐  ┌───────────┐          │ ││
│  │  │  用戶管理  │  │  │  商品目錄  │  │  訂單處理  │          │ ││
│  │  │  模組     │  │  │  模組     │  │  模組     │          │ ││
│  │  └─────┬─────┘  │  └─────┬─────┘  └─────┬─────┘          │ ││
│  │        │        │        │              │                │ ││
│  │  ┌───────────┐  │  ┌───────────┐  ┌───────────┐          │ ││
│  │  │  購物車   │  │  │  庫存管理  │  │  支付處理  │          │ ││
│  │  │  模組     │  │  │  模組     │  │  模組     │          │ ││
│  │  └─────┬─────┘  │  └─────┬─────┘  └─────┬─────┘          │ ││
│  │        │        │        │              │                │ ││
│  │  ┌───────────┐  │  ┌───────────┐  ┌───────────┐          │ ││
│  │  │  搜尋功能  │  │  │  通知服務  │  │  報表分析  │          │ ││
│  │  │  模組     │  │  │  模組     │  │  模組     │          │ ││
│  │  └───────────┘  │  └───────────┘  └───────────┘          │ ││
│  │                 │                                         │ ││
│  │  ─────────────────────────────────────────────────────── │ ││
│  │                    共用程式庫與框架                        │ ││
│  │  ─────────────────────────────────────────────────────── │ ││
│  │                                                          │ ││
│  └──────────────────────────────────────────────────────────┘ ││
│                    │                                          │ │
│                    │                                          │ │
│                    ▼                                          │ │
│              ┌──────────────┐                                 │ │
│              │   PostgreSQL │                                 │ │
│              │   (單一資料庫) │                                │ │
│              └──────────────┘                                 │ │
│                                                                 │
│  所有模組：                                                      │
│  • 共享相同的程式碼庫                                            │
│  • 共享相同的資料庫                                              │
│  • 一起部署、一起升級                                            │
│  • 一個模組崩潰，整個應用崩潰                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2.2 單體架構的優點

| 優點 | 說明 |
|------|------|
| **開發簡單** | 一個專案、一個程式碼庫，容易理解 |
| **部署簡單** | 打包成一個檔案，部署到一台伺服器 |
| **測試簡單** | 端到端測試容易執行 |
| **效能好** | 模組間呼叫是本機函數呼叫，沒有網路延遲 |
| **事務處理簡單** | 資料庫事務容易管理 |

**適合場景：**
- 新創公司的 MVP（最小可行產品）
- 小型團隊（少於 10 人）
- 業務邏輯相對簡單的應用

### 4.2.3 單體架構的問題

當 CloudMart 成長後，問題逐漸浮現：

```
┌─────────────────────────────────────────────────────────────────┐
│                   單體架構的痛點                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1️⃣ 程式碼耦合嚴重                                               │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  「我只是改了商品價格的顯示格式，                          │ │
│  │   結果購物車和訂單確認頁都壞了。」                          │ │
│  │                                                           │ │
│  │  商品模組 ←──引用──→ 購物車模組 ←──引用──→ 訂單模組       │ │
│  │      ↑                    ↑                  ↑            │ │
│  │      └────────────────────┴──────────────────┘            │ │
│  │                    共用 Product 類別                       │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  2️⃣ 無法獨立擴展                                                │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  「搜尋功能需要 10 台伺服器，                              │ │
│  │   但報表分析只需要 1 台。                                  │ │
│  │   然而它們綁在一起，只能一起擴展。」                        │ │
│  │                                                           │ │
│  │  需求：搜尋 10x ──► 實際：全部 10x ──► 浪費 9x 報表資源    │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  3️⃣ 技術棧被鎖定                                                │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  「我們想用 Python 重寫機器學習推薦系統，                   │ │
│  │   但整個應用是用 Node.js 寫的，改不了。」                   │ │
│  │                                                           │ │
│  │  整個應用 = 一種語言 + 一種框架 + 一種資料庫                │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  4️⃣ 部署風險高                                                  │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  「每次部署都像是賭博。                                    │ │
│  │   就算只改了一行程式碼，也要重新部署整個系統。」            │ │
│  │                                                           │ │
│  │  改動範圍：1 行 ──► 部署範圍：100 萬行 ──► 風險：巨大      │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  5️⃣ 團隊協作困難                                                │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  「10 個工程師同時修改一個程式碼庫，                        │ │
│  │   每天光是解決合併衝突就要花 2 小時。」                     │ │
│  │                                                           │ │
│  │  Team A 改 User ──┐                                       │ │
│  │  Team B 改 Cart ──┼──► 衝突！                             │ │
│  │  Team C 改 Order ─┘                                       │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4.3 微服務架構：分而治之

### 4.3.1 什麼是微服務？

**微服務架構（Microservices Architecture）** 將應用程式拆分為一組小型、獨立的服務，每個服務：

- 專注於單一業務功能
- 可以獨立開發、部署、擴展
- 透過網路 API 與其他服務溝通
- 可以使用不同的技術棧

```
┌─────────────────────────────────────────────────────────────────┐
│                   CloudMart 微服務架構                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                         API Gateway                              │
│                    ┌─────────────────┐                          │
│                    │  Azure API Mgmt │                          │
│                    └────────┬────────┘                          │
│                             │                                    │
│           ┌─────────────────┼─────────────────┐                  │
│           │                 │                 │                  │
│           ▼                 ▼                 ▼                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                     服務網格                             │    │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐       │    │
│  │  │  User   │ │ Product │ │  Order  │ │  Cart   │       │    │
│  │  │ Service │ │ Service │ │ Service │ │ Service │       │    │
│  │  │         │ │         │ │         │ │         │       │    │
│  │  │ Node.js │ │   Go    │ │  Java   │ │ Node.js │       │    │
│  │  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘       │    │
│  │       │           │           │           │             │    │
│  │       ▼           ▼           ▼           ▼             │    │
│  │  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐        │    │
│  │  │MongoDB │  │PostgreS│  │PostgreS│  │ Redis  │        │    │
│  │  │        │  │   QL   │  │   QL   │  │        │        │    │
│  │  └────────┘  └────────┘  └────────┘  └────────┘        │    │
│  │                                                         │    │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐       │    │
│  │  │ Search  │ │ Payment │ │ Notify  │ │Analytics│       │    │
│  │  │ Service │ │ Service │ │ Service │ │ Service │       │    │
│  │  │         │ │         │ │         │ │         │       │    │
│  │  │ Python  │ │   Go    │ │ Node.js │ │ Python  │       │    │
│  │  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘       │    │
│  │       │           │           │           │             │    │
│  │       ▼           ▼           ▼           ▼             │    │
│  │  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐        │    │
│  │  │Elastic │  │  專用   │  │ Queue  │  │BigQuery│        │    │
│  │  │ Search │  │ 安全DB │  │        │  │        │        │    │
│  │  └────────┘  └────────┘  └────────┘  └────────┘        │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  每個服務：                                                      │
│  • 獨立的程式碼庫（可以不同語言）                                 │
│  • 獨立的資料庫（避免耦合）                                       │
│  • 獨立部署（不影響其他服務）                                     │
│  • 獨立擴展（按需求調整）                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3.2 單體 vs. 微服務比較

| 面向 | 單體架構 | 微服務架構 |
|------|---------|-----------|
| **程式碼** | 一個程式碼庫 | 多個程式碼庫 |
| **部署** | 整體部署 | 獨立部署 |
| **擴展** | 整體擴展 | 獨立擴展 |
| **技術棧** | 統一 | 可混用 |
| **團隊** | 大團隊協作 | 小團隊獨立 |
| **故障** | 一處故障，全體崩潰 | 故障隔離 |
| **複雜度** | 低（初期） | 高（需要更多基礎設施） |
| **網路** | 本機呼叫 | 需要網路通訊 |
| **資料一致性** | 簡單（ACID） | 複雜（最終一致性） |

### 4.3.3 CloudMart 服務拆分策略

```
┌─────────────────────────────────────────────────────────────────┐
│                   服務拆分策略                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  原則 1：按業務領域拆分（Domain-Driven Design）                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  用戶領域 ────────► User Service                                │
│  ├── 註冊、登入                                                 │
│  ├── 個人資料管理                                               │
│  └── 地址管理                                                   │
│                                                                 │
│  商品領域 ────────► Product Service                             │
│  ├── 商品資訊                                                   │
│  ├── 分類管理                                                   │
│  └── 商品搜尋                                                   │
│                                                                 │
│  訂單領域 ────────► Order Service                               │
│  ├── 訂單建立                                                   │
│  ├── 訂單狀態                                                   │
│  └── 訂單歷史                                                   │
│                                                                 │
│  ═══════════════════════════════════════════════════════════   │
│                                                                 │
│  原則 2：按擴展需求拆分                                          │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  高流量功能：                                                    │
│  • 商品搜尋 ──► 需要 10x 擴展 ──► 獨立 Search Service           │
│  • 商品瀏覽 ──► 需要 5x 擴展 ──► 獨立 Product Service           │
│                                                                 │
│  低流量但高安全：                                                │
│  • 支付處理 ──► 需要特殊安全 ──► 獨立 Payment Service           │
│                                                                 │
│  ═══════════════════════════════════════════════════════════   │
│                                                                 │
│  原則 3：按團隊組織拆分（康威定律）                               │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  「軟體的架構會反映組織的溝通結構。」                             │
│                                                                 │
│  用戶體驗團隊 ──► Frontend + BFF                                │
│  商品團隊 ──────► Product + Search + Inventory                  │
│  交易團隊 ──────► Order + Payment + Notification                │
│  數據團隊 ──────► Analytics + Recommendation                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4.4 容器化：打包你的應用程式

### 4.4.1 為什麼需要容器？

在微服務架構中，我們可能有數十個服務需要部署。每個服務可能需要不同的：

- 程式語言版本（Node.js 14 vs 18）
- 系統函式庫（libssl 1.1 vs 3.0）
- 環境變數設定

**傳統部署的問題：**

```
┌─────────────────────────────────────────────────────────────────┐
│                  「在我電腦上可以跑啊！」                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  開發環境                           生產環境                     │
│  ┌─────────────────────┐           ┌─────────────────────┐     │
│  │  macOS Sonoma       │           │  Ubuntu 22.04       │     │
│  │  Node.js 20.10.0    │    ✗      │  Node.js 18.17.0    │     │
│  │  OpenSSL 3.0        │  ─────►   │  OpenSSL 1.1        │     │
│  │  Memory: 32GB       │   部署    │  Memory: 4GB        │     │
│  └─────────────────────┘           └─────────────────────┘     │
│           ↓                                  ↓                  │
│        正常運行                          崩潰！                  │
│                                                                 │
│  常見問題：                                                      │
│  • 系統函式庫版本不同                                            │
│  • 環境變數遺漏                                                  │
│  • 權限設定不同                                                  │
│  • 路徑不存在                                                    │
│  • 依賴套件版本衝突                                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.4.2 容器的解決方案

**容器（Container）** 將應用程式與其所有依賴項打包在一起，確保在任何環境中都能一致地運行。

```
┌─────────────────────────────────────────────────────────────────┐
│                    容器化概念                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│              傳統部署                    容器化部署              │
│                                                                 │
│  ┌─────────────────────────┐    ┌─────────────────────────┐    │
│  │       應用程式 A        │    │       容器 A            │    │
│  └───────────┬─────────────┘    │  ┌─────────────────┐   │    │
│              │                  │  │   應用程式 A    │   │    │
│              ▼                  │  ├─────────────────┤   │    │
│  ┌─────────────────────────┐    │  │  執行環境       │   │    │
│  │   執行環境（共用）       │    │  │  Node.js 20    │   │    │
│  │   Node.js 18            │    │  ├─────────────────┤   │    │
│  └───────────┬─────────────┘    │  │  系統函式庫     │   │    │
│              │                  │  │  OpenSSL 3.0   │   │    │
│              ▼                  │  └─────────────────┘   │    │
│  ┌─────────────────────────┐    └─────────────────────────┘    │
│  │   作業系統              │                                   │
│  │   Ubuntu 22.04          │    ┌─────────────────────────┐    │
│  └───────────┬─────────────┘    │       容器 B            │    │
│              │                  │  ┌─────────────────┐   │    │
│              ▼                  │  │   應用程式 B    │   │    │
│  ┌─────────────────────────┐    │  ├─────────────────┤   │    │
│  │   硬體                  │    │  │  Python 3.11   │   │    │
│  └─────────────────────────┘    │  ├─────────────────┤   │    │
│                                 │  │  不同的函式庫   │   │    │
│  問題：                         │  └─────────────────┘   │    │
│  • 依賴衝突                    └─────────────────────────┘    │
│  • 環境不一致                         │                        │
│  • 難以複製環境                       ▼                        │
│                                 ┌─────────────────────────┐    │
│                                 │     容器引擎 (Docker)   │    │
│                                 └───────────┬─────────────┘    │
│                                             ▼                  │
│                                 ┌─────────────────────────┐    │
│                                 │   作業系統 (共用核心)   │    │
│                                 └─────────────────────────┘    │
│                                                                 │
│                                 優點：                          │
│                                 • 環境一致                     │
│                                 • 隔離運行                     │
│                                 • 快速啟動                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.4.3 容器 vs. 虛擬機

```
┌─────────────────────────────────────────────────────────────────┐
│                   容器 vs. 虛擬機                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│           虛擬機 (VM)                        容器               │
│                                                                 │
│  ┌─────┐ ┌─────┐ ┌─────┐          ┌─────┐ ┌─────┐ ┌─────┐     │
│  │App A│ │App B│ │App C│          │App A│ │App B│ │App C│     │
│  ├─────┤ ├─────┤ ├─────┤          ├─────┤ ├─────┤ ├─────┤     │
│  │Libs │ │Libs │ │Libs │          │Libs │ │Libs │ │Libs │     │
│  ├─────┤ ├─────┤ ├─────┤          └──┬──┘ └──┬──┘ └──┬──┘     │
│  │Guest│ │Guest│ │Guest│             │       │       │        │
│  │ OS  │ │ OS  │ │ OS  │             └───────┼───────┘        │
│  └──┬──┘ └──┬──┘ └──┬──┘                     │                │
│     │       │       │               ┌────────┴────────┐       │
│     └───────┼───────┘               │  Container      │       │
│             │                       │  Runtime        │       │
│     ┌───────┴───────┐               │  (Docker)       │       │
│     │   Hypervisor  │               └────────┬────────┘       │
│     └───────┬───────┘                        │                │
│             │                                │                │
│     ┌───────┴───────┐               ┌────────┴────────┐       │
│     │   Host OS     │               │    Host OS      │       │
│     └───────┬───────┘               └────────┬────────┘       │
│             │                                │                │
│     ┌───────┴───────┐               ┌────────┴────────┐       │
│     │   Hardware    │               │    Hardware     │       │
│     └───────────────┘               └─────────────────┘       │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │        比較項目           虛擬機          容器          │   │
│  ├─────────────────────────────────────────────────────────┤   │
│  │  啟動時間                 分鐘級          秒級          │   │
│  │  磁碟佔用                 GB 級          MB 級          │   │
│  │  記憶體佔用               較高           較低           │   │
│  │  效能                     有損耗         接近原生        │   │
│  │  隔離性                   強             較弱           │   │
│  │  可攜性                   較低           高             │   │
│  │  密度                     低             高             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4.5 Docker：容器化的標準工具

### 4.5.1 Docker 核心概念

```
┌─────────────────────────────────────────────────────────────────┐
│                    Docker 核心概念                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Dockerfile ────► Image ────► Container                         │
│  (建構指令)       (映像檔)     (執行實例)                         │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  Dockerfile（建構指令）                                    │ │
│  │                                                           │ │
│  │  一個文字檔案，包含建構映像的所有指令                       │ │
│  │  類似於「食譜」                                            │ │
│  └───────────────────────────────────────────────────────────┘ │
│                     │                                           │
│                     │ docker build                              │
│                     ▼                                           │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  Image（映像檔）                                           │ │
│  │                                                           │ │
│  │  唯讀的模板，包含運行應用程式所需的一切                     │ │
│  │  類似於「蛋糕模具」                                        │ │
│  │  可以推送到 Registry（如 Docker Hub、Azure ACR）          │ │
│  └───────────────────────────────────────────────────────────┘ │
│                     │                                           │
│                     │ docker run                                │
│                     ▼                                           │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  Container（容器）                                         │ │
│  │                                                           │ │
│  │  映像的執行實例                                            │ │
│  │  類似於「烤好的蛋糕」                                      │ │
│  │  可以有多個容器基於同一個映像                              │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  Registry（映像倉庫）                                           │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  儲存和分發映像的服務                                      │ │
│  │  • Docker Hub（公開）                                      │ │
│  │  • Azure Container Registry（私有）                        │ │
│  │  • Amazon ECR                                             │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.5.2 撰寫 Dockerfile

```dockerfile
# CloudMart Order Service Dockerfile
# 多階段建構（Multi-stage build）以減少映像大小

# === 建構階段 ===
FROM node:20-alpine AS builder

# 設定工作目錄
WORKDIR /app

# 複製 package.json 和 lock 檔案
COPY package*.json ./

# 安裝依賴（只安裝生產依賴）
RUN npm ci --only=production

# 複製原始碼
COPY . .

# 建構 TypeScript
RUN npm run build

# === 執行階段 ===
FROM node:20-alpine AS runner

# 設定環境變數
ENV NODE_ENV=production
ENV PORT=3000

# 建立非 root 使用者
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# 設定工作目錄
WORKDIR /app

# 從建構階段複製必要檔案
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package.json ./

# 切換到非 root 使用者
USER nodejs

# 暴露連接埠
EXPOSE 3000

# 健康檢查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

# 啟動命令
CMD ["node", "dist/index.js"]
```

### 4.5.3 建構和執行 Docker 映像

```bash
# 建構映像
docker build -t cloudmart/order-service:v1.0.0 .

# 查看映像
docker images
# REPOSITORY                   TAG       SIZE
# cloudmart/order-service      v1.0.0    125MB

# 執行容器
docker run -d \
    --name order-service \
    -p 3000:3000 \
    -e DATABASE_URL=postgresql://... \
    -e REDIS_URL=redis://... \
    cloudmart/order-service:v1.0.0

# 查看執行中的容器
docker ps
# CONTAINER ID   IMAGE                           STATUS    PORTS
# abc123         cloudmart/order-service:v1.0.0  Up 5min   0.0.0.0:3000->3000/tcp

# 查看日誌
docker logs order-service

# 進入容器
docker exec -it order-service /bin/sh

# 停止容器
docker stop order-service

# 刪除容器
docker rm order-service
```

### 4.5.4 Docker Compose：多容器編排

```yaml
# docker-compose.yml
# CloudMart 本地開發環境

version: '3.8'

services:
  # API Gateway
  gateway:
    build: ./gateway
    ports:
      - "8080:8080"
    environment:
      - USER_SERVICE_URL=http://user-service:3001
      - PRODUCT_SERVICE_URL=http://product-service:3002
      - ORDER_SERVICE_URL=http://order-service:3003
    depends_on:
      - user-service
      - product-service
      - order-service

  # User Service
  user-service:
    build: ./services/user
    ports:
      - "3001:3000"
    environment:
      - DATABASE_URL=mongodb://mongo:27017/users
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - mongo

  # Product Service
  product-service:
    build: ./services/product
    ports:
      - "3002:3000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/products
      - ELASTICSEARCH_URL=http://elasticsearch:9200
    depends_on:
      - postgres
      - elasticsearch

  # Order Service
  order-service:
    build: ./services/order
    ports:
      - "3003:3000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/orders
      - REDIS_URL=redis://redis:6379
      - RABBITMQ_URL=amqp://rabbitmq:5672
    depends_on:
      - postgres
      - redis
      - rabbitmq

  # Databases
  postgres:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  mongo:
    image: mongo:6
    volumes:
      - mongo_data:/data/db

  redis:
    image: redis:7-alpine

  elasticsearch:
    image: elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    volumes:
      - es_data:/usr/share/elasticsearch/data

  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "15672:15672"  # Management UI

volumes:
  postgres_data:
  mongo_data:
  es_data:
```

```bash
# 啟動所有服務
docker-compose up -d

# 查看服務狀態
docker-compose ps

# 查看日誌
docker-compose logs -f order-service

# 停止所有服務
docker-compose down

# 停止並刪除資料
docker-compose down -v
```

---

## 4.6 Kubernetes：容器編排平台

### 4.6.1 為什麼需要 Kubernetes？

當你有數十個微服務、數百個容器時，手動管理變得不可能。

**需要自動化的工作：**

- 容器的部署和更新
- 服務發現和負載平衡
- 自動擴展
- 健康檢查和自癒
- 配置和密鑰管理
- 儲存編排

**Kubernetes（K8s）** 是一個開源的容器編排平台，自動化這些工作。

### 4.6.2 Kubernetes 核心概念

```
┌─────────────────────────────────────────────────────────────────┐
│                  Kubernetes 核心概念                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Cluster（叢集）                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │  Control Plane（控制平面）                               │   │
│  │  ┌─────────────────────────────────────────────────┐   │   │
│  │  │  • API Server：所有請求的入口                    │   │   │
│  │  │  • Scheduler：決定 Pod 運行在哪個節點            │   │   │
│  │  │  • Controller Manager：維護叢集狀態              │   │   │
│  │  │  • etcd：分散式鍵值資料庫，儲存叢集狀態          │   │   │
│  │  └─────────────────────────────────────────────────┘   │   │
│  │                           │                             │   │
│  │           ┌───────────────┼───────────────┐             │   │
│  │           │               │               │             │   │
│  │           ▼               ▼               ▼             │   │
│  │  Worker Node 1    Worker Node 2    Worker Node 3        │   │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │   │
│  │  │   kubelet   │ │   kubelet   │ │   kubelet   │       │   │
│  │  │ ┌─────────┐ │ │ ┌─────────┐ │ │ ┌─────────┐ │       │   │
│  │  │ │  Pod A  │ │ │ │  Pod B  │ │ │ │  Pod C  │ │       │   │
│  │  │ │┌───────┐│ │ │ │┌───────┐│ │ │ │┌───────┐│ │       │   │
│  │  │ ││Contai-││ │ │ ││Contai-││ │ │ ││Contai-││ │       │   │
│  │  │ ││ner    ││ │ │ ││ner    ││ │ │ ││ner    ││ │       │   │
│  │  │ │└───────┘│ │ │ │└───────┘│ │ │ │└───────┘│ │       │   │
│  │  │ └─────────┘ │ │ └─────────┘ │ │ └─────────┘ │       │   │
│  │  └─────────────┘ └─────────────┘ └─────────────┘       │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  核心資源：                                                      │
│  • Pod：最小部署單位，一個或多個容器                            │
│  • Deployment：宣告式的 Pod 管理                                │
│  • Service：服務發現和負載平衡                                  │
│  • ConfigMap/Secret：配置和密鑰管理                             │
│  • Ingress：HTTP 路由                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.6.3 Kubernetes YAML 設定範例

```yaml
# order-service-deployment.yaml
# CloudMart Order Service 部署設定

apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  namespace: cloudmart
  labels:
    app: order-service
    version: v1.0.0
spec:
  replicas: 3  # 運行 3 個副本
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
        version: v1.0.0
    spec:
      containers:
        - name: order-service
          image: cloudmart.azurecr.io/order-service:v1.0.0
          ports:
            - containerPort: 3000
          env:
            - name: NODE_ENV
              value: "production"
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: order-service-secrets
                  key: database-url
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 10
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /ready
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: order-service
  namespace: cloudmart
spec:
  selector:
    app: order-service
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: order-service-hpa
  namespace: cloudmart
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: order-service
  minReplicas: 3
  maxReplicas: 20
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
```

---

## 4.7 Azure 容器服務

### 4.7.1 Azure 容器服務選項

| 服務 | 說明 | 適用場景 |
|------|------|----------|
| **Azure Container Instances (ACI)** | 無伺服器容器 | 簡單工作負載、批次處理 |
| **Azure App Service** | PaaS 容器託管 | Web 應用程式 |
| **Azure Kubernetes Service (AKS)** | 託管 K8s | 複雜微服務架構 |
| **Azure Container Apps** | 無伺服器 K8s | 事件驅動應用 |

### 4.7.2 使用 Azure Container Registry

```bash
# 建立 Container Registry
az acr create \
    --resource-group CloudMart-Production \
    --name cloudmartacr \
    --sku Standard

# 登入 Registry
az acr login --name cloudmartacr

# 標記映像
docker tag cloudmart/order-service:v1.0.0 \
    cloudmartacr.azurecr.io/order-service:v1.0.0

# 推送映像
docker push cloudmartacr.azurecr.io/order-service:v1.0.0

# 查看映像
az acr repository list --name cloudmartacr
```

### 4.7.3 使用 Azure Kubernetes Service

```bash
# 建立 AKS 叢集
az aks create \
    --resource-group CloudMart-Production \
    --name cloudmart-aks \
    --node-count 3 \
    --node-vm-size Standard_D4s_v3 \
    --enable-addons monitoring \
    --generate-ssh-keys \
    --attach-acr cloudmartacr

# 取得叢集認證
az aks get-credentials \
    --resource-group CloudMart-Production \
    --name cloudmart-aks

# 部署應用程式
kubectl apply -f order-service-deployment.yaml

# 查看部署狀態
kubectl get deployments -n cloudmart
kubectl get pods -n cloudmart
kubectl get services -n cloudmart

# 查看日誌
kubectl logs -f deployment/order-service -n cloudmart
```

---

## 4.8 章節總結

### 核心概念回顧

| 概念 | 說明 | Azure 服務 |
|------|------|-----------|
| **單體架構** | 所有功能在一個應用中 | - |
| **微服務** | 拆分為獨立的小服務 | - |
| **容器** | 打包應用和依賴 | Azure Container Registry |
| **Docker** | 容器化工具 | - |
| **Kubernetes** | 容器編排平台 | Azure Kubernetes Service |
| **映像** | 容器的唯讀模板 | ACR |
| **Pod** | K8s 最小部署單位 | AKS |

### AZ-900 考試重點

1. **容器 vs. 虛擬機**：知道兩者的差異和適用場景
2. **Azure 容器服務**：ACI、AKS、Container Apps 的區別
3. **微服務優點**：獨立部署、獨立擴展、技術異構
4. **Kubernetes 基礎**：Pod、Deployment、Service 的概念

### 學習檢查清單

完成本章後，請確認你可以：

- [ ] 解釋單體架構和微服務架構的差異
- [ ] 說明容器化解決的問題
- [ ] 撰寫基本的 Dockerfile
- [ ] 使用 Docker 建構和運行容器
- [ ] 理解 Kubernetes 的核心概念
- [ ] 在 Azure 上部署容器化應用

---

## 4.9 下一章預告

在下一章「流量管理與非同步溝通」中，我們將探討：

- 如何使用負載平衡器分散流量？
- API Gateway 如何統一管理微服務的入口？
- 訊息佇列如何實現服務間的非同步溝通？
- 如何設計能夠應對流量高峰的系統？

這些知識將幫助你理解如何建構高可用、高效能的分散式系統。

---

## 延伸閱讀

- [Docker 官方文件](https://docs.docker.com/)
- [Kubernetes 官方文件](https://kubernetes.io/docs/)
- [Azure Kubernetes Service 文件](https://docs.microsoft.com/azure/aks/)
- [微服務架構模式](https://microservices.io/)

---

**上一章：[第 3 章：連接世界的大門](./chapter-03.md)**

**下一章：[第 5 章：流量管理與非同步溝通](./chapter-05.md)**
