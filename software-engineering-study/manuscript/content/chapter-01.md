# 第1章　軟體與軟體工程

> 「軟體工程不是寫程式的科學，而是在限制下管理變更的藝術。」

---

## 1.1 為什麼需要談軟體工程？

在開始之前，讓我問你一個問題：

**你寫的程式碼，有多少最終活過了一年？**

如果你誠實回答，答案可能令人沮喪。我們每天都在寫程式碼，但大部分程式碼的命運是：

- 寫完沒人用
- 用了一陣子就被拋棄
- 維護成本超過重寫成本
- 只有作者自己看得懂

這些現象不是你的問題，而是「軟體」這個東西的本質問題。理解這個本質，就是理解為什麼我們需要「工程」。

---

## 1.2 軟體的本質：看不見的複雜性

### 軟體不是硬體

這句話聽起來像廢話，但它蘊含的意義遠比你想的深。

| 特性 | 硬體 | 軟體 |
|------|------|------|
| **可見性** | 看得見、摸得著 | 看不見、只有執行結果可見 |
| **磨損** | 會老化、損耗 | 不會磨損，但會「腐爛」 |
| **製造** | 設計後批量生產 | 每一份都是「設計」 |
| **修改成本** | 模具改了就改了 | 「改一行」可能牽動全局 |
| **錯誤** | 可以事後檢測 | 錯誤在執行時才顯現 |
| **複製** | 有成本 | 幾乎零成本 |

**關鍵洞察**：軟體的所有困難，都來自它的「不可見性」。

你無法「看見」程式碼的結構是否合理，無法「觸摸」模組之間的耦合程度，無法「聽到」技術債的累積。這種不可見性導致：

1. **溝通困難**：每個人腦中的「系統」長得不一樣
2. **估算困難**：看不見的東西無法度量
3. **品質困難**：問題隱藏到執行時才爆發
4. **維護困難**：修改的影響範圍無法預測

### 軟體的四個本質特徵

Frederick Brooks 在《人月神話》中提出軟體的四個本質困難：

**1. 複雜性（Complexity）**

軟體系統的複雜度不是線性增長，而是指數增長。一個 10 萬行的系統，其複雜度不是 1 萬行系統的 10 倍，而可能是 100 倍。

原因：軟體沒有兩個部分是完全相同的（否則就該抽成函數了），所以每增加一個部分，就增加了與所有現有部分的潛在交互。

**2. 一致性（Conformity）**

軟體必須配合外部世界：遵守協定、對接系統、適應組織流程。這些外部強加的規則沒有內在邏輯可言，純粹是「歷史原因」。

你不能說：「這個 API 設計不合理，我不配合。」你只能適應。

**3. 可變性（Changeability）**

軟體是最容易被要求修改的人造物。建築師不會被要求「把地下室移到頂樓」，但軟體工程師經常被要求「把這個功能的邏輯反過來」。

因為看起來「只是改程式碼」，所以人們低估了變更的成本。

**4. 不可見性（Invisibility）**

軟體沒有空間形態，無法用圖形完整表達。UML、架構圖、流程圖都只是軟體的「投影」，而非全貌。

這導致我們無法像建築師審視模型那樣審視軟體。

---

## 1.3 工程的本質：在限制下交付

### 工程 vs. 科學 vs. 工藝

在討論「軟體工程」之前，我們需要先理解「工程」是什麼。

| 領域 | 目標 | 方法 | 成功標準 |
|------|------|------|----------|
| **科學** | 發現真理 | 假說、實驗、證偽 | 理論正確 |
| **工藝** | 創造美 | 經驗、直覺、技藝 | 主觀滿意 |
| **工程** | 解決問題 | 權衡、設計、驗證 | 在限制下交付 |

**工程的核心特徵**：

1. **有限制**：時間、預算、人力、技術、法規
2. **要交付**：可運作的成果，不是研究報告
3. **可權衡**：沒有「最佳解」，只有「在限制下的最適解」
4. **可驗證**：有明確的成功/失敗標準

### 軟體工程的定義

> **軟體工程是將系統化的、有紀律的、可量化的方法應用於軟體的開發、運作和維護；也就是說，將工程應用於軟體。**
>
> — IEEE Standard 610.12

但這個定義太學術了。讓我給你一個更實用的定義：

> **軟體工程 = 在不確定性下，持續交付價值的系統化方法。**

關鍵詞：
- **不確定性**：需求會變、技術會變、人會變
- **持續**：不是一次交付，而是持續演進
- **價值**：不是程式碼，而是使用者價值
- **系統化**：可重複、可傳承、可改進

---

## 1.4 軟體危機：為什麼簡單的事變得這麼難？

### 1968 年的覺醒

1968 年，NATO 在德國召開了一場會議，首次使用「軟體工程」這個詞。會議的背景是：

- 軟體專案超支、延期成為常態
- 交付的軟體品質低劣
- 維護成本遠超開發成本
- 專案失敗率高得驚人

他們稱之為「軟體危機」（Software Crisis）。

### 50 年後的今天

2024 年，Standish Group 的 CHAOS Report 顯示：

| 專案結果 | 比例 |
|----------|------|
| 成功（按時、按預算、符合需求） | 31% |
| 挑戰（超時、超支、或功能縮減） | 52% |
| 失敗（取消或從未使用） | 17% |

50 年過去了，情況有改善嗎？有，但沒有根本性改變。

### 為什麼軟體危機持續存在？

**1. 複雜度在增長**

1968 年的軟體可能是幾千行程式碼，今天一個普通的 Web 應用（包含依賴）可能是幾百萬行。複雜度的增長速度超過了我們駕馭它的能力增長速度。

**2. 期望在增長**

過去一個軟體可以運行就好，現在要求：高可用、高效能、高安全、好用、好看、跨平台、持續更新。

**3. 本質問題無法消除**

Brooks 指出，軟體的本質困難（複雜性、一致性、可變性、不可見性）是無法用任何銀彈消除的。我們只能學習與之共處。

**4. 人的問題**

軟體是人寫的，人有認知限制、溝通障礙、利益衝突、情緒起伏。任何流程和工具最終都要通過人來執行。

---

## 1.5 軟體工程的核心活動

既然軟體危機無法完全解決，我們能做什麼？答案是：建立一套系統化的方法來「管理」這些困難。

軟體工程的核心活動可以分為四類：

### 1. 溝通（Communication）

**目標**：確保所有人對「要做什麼」有共同理解。

包含：
- 需求蒐集與分析
- 利害關係人識別
- 需求驗證與確認
- 持續的回饋機制

**為什麼重要**：軟體專案失敗的首要原因不是技術，而是需求問題。

### 2. 規劃（Planning）

**目標**：在不確定性下做出承諾，並持續調整。

包含：
- 估算（時程、成本、資源）
- 風險識別與緩解
- 里程碑與交付物定義
- 追蹤與調整機制

**為什麼重要**：沒有計畫的專案就像沒有地圖的旅行，你可能會到達某個地方，但不一定是你想去的。

### 3. 建模（Modeling）

**目標**：讓不可見的軟體變得「可見」，以便分析、溝通、驗證。

包含：
- 需求模型（用例、使用者故事、資料流）
- 設計模型（架構、元件、介面）
- 分析模型（效能、安全、可用性）

**為什麼重要**：模型是「便宜的實驗」——在寫程式碼之前發現問題，成本遠低於之後。

### 4. 建構與驗證（Construction & Verification）

**目標**：將設計轉化為可運作的軟體，並確保其符合預期。

包含：
- 程式碼撰寫
- 測試（單元、整合、系統、驗收）
- 程式碼審查
- 持續整合與部署

**為什麼重要**：這是唯一產生實際價值的活動，但如果前面的活動做不好，這裡的效率會大打折扣。

### 5. 部署與支援（Deployment & Support）

**目標**：讓軟體在真實環境中運作，並持續維護。

包含：
- 部署策略
- 監控與告警
- 事件響應
- 維護與演進

**為什麼重要**：軟體的價值在「被使用」時才實現，開發完成只是開始。

---

## 1.6 軟體工程的核心原則

在結束本章之前，讓我提煉幾個貫穿全書的核心原則：

### 原則 1：所有問題都是溝通問題

技術問題往往可以解決，但溝通問題會殺死專案。確保每個人都理解同樣的事情，比寫出完美的程式碼更重要。

### 原則 2：越早發現問題，修復成本越低

需求階段發現的問題，修復成本是 1；設計階段是 5；編碼階段是 10；測試階段是 50；上線後是 200。投資在早期驗證，回報巨大。

### 原則 3：沒有銀彈，只有權衡

不存在「最佳實踐」，只存在「在特定情境下的適當選擇」。每個決策都是權衡，理解你在權衡什麼，比選擇本身更重要。

### 原則 4：人比流程重要，但流程幫助人

優秀的人可以在糟糕的流程中成功，糟糕的人會讓最好的流程失敗。但好的流程能幫助普通人做出不普通的成果。

### 原則 5：軟體工程是持續改進的過程

沒有完美的流程、完美的設計、完美的程式碼。重要的是建立回饋機制，讓系統能持續學習和改進。

---

## 1.7 本章總結

### 核心概念

| 概念 | 一句話解釋 |
|------|-----------|
| 軟體的本質困難 | 複雜性、一致性、可變性、不可見性 |
| 工程的本質 | 在限制下交付可驗證的成果 |
| 軟體危機 | 複雜度增長超過駕馭能力增長 |
| 軟體工程 | 在不確定性下持續交付價值的系統化方法 |

### 你應該帶走什麼

1. 軟體的困難不是「還沒找到銀彈」，而是本質使然
2. 工程思維的核心是「權衡」，不是追求完美
3. 軟體工程解決的不是技術問題，而是「人 + 技術 + 時間」的問題
4. 所有流程和方法的目的都是：降低不確定性、加速回饋、減少返工

### 下一章預告

在理解了軟體工程的本質後，下一章我們將進入「流程模型」——如何組織工作、何時交付、如何迭代。你會學到：瀑布、增量、螺旋、敏捷等模型的本質差異，以及如何根據情境選擇。

---

## 延伸思考

1. 回顧你參與過的專案，失敗或困難的根本原因是什麼？是技術問題，還是溝通、需求、人的問題？

2. 「軟體工程」這個詞暗示軟體開發可以像土木工程一樣可預測、可控制。你同意嗎？為什麼？

3. Brooks 說「沒有銀彈」，但 AI、低代碼、雲服務等新技術是否改變了這個判斷？

---

*下一章：第2章　流程模型*
