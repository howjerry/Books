# 第6章　作為實務指引的原則

> 「原則是『為什麼』的答案，實踐是『怎麼做』的答案。知道原則，才能在新情境中創造新實踐。」

---

## 6.1 為什麼需要原則？

在前面的章節，我們學習了流程模型和敏捷方法。但流程和方法會過時，新的框架不斷出現。

**今天的最佳實踐，可能是明天的反模式。**

那麼，有什麼是不變的？答案是：**原則**。

### 實踐 vs. 原則

| 層次 | 特徵 | 例子 |
|------|------|------|
| **實踐** | 具體做法，情境依賴 | Scrum、TDD、Code Review |
| **原則** | 抽象指導，相對穩定 | 關注點分離、快速回饋、簡單 |

實踐會變，原則相對穩定。理解原則，你就能：
- 評估新實踐是否有價值
- 在新情境中創造適合的實踐
- 解釋為什麼某些做法有效

---

## 6.2 核心原則總覽

軟體工程的核心原則可以分為幾個層次：

```
┌─────────────────────────────────────────┐
│           通用工程原則                    │
│   (適用於所有軟體工程活動)                │
├─────────────────────────────────────────┤
│  溝通原則  │  規劃原則  │  建模原則       │
├─────────────────────────────────────────┤
│       建構原則       │      部署原則      │
└─────────────────────────────────────────┘
```

---

## 6.3 通用工程原則

這些原則適用於所有軟體工程活動。

### 原則 1：存在的理由（Reason for Existence）

> **軟體系統存在的唯一理由是為使用者提供價值。**

所有決策都應該問：「這對使用者有什麼價值？」

**應用**：
- 功能取捨時，優先考慮使用者價值
- 技術選型時，考慮對使用者體驗的影響
- 不要為了技術的「優雅」而犧牲使用者價值

### 原則 2：保持簡單（KISS - Keep It Simple, Stupid）

> **所有設計應該盡可能簡單，但不能更簡單。**

複雜是軟體的大敵。每增加一分複雜度，就增加一分出錯的機會。

**應用**：
- 選擇最簡單的能解決問題的方案
- 避免過度設計（Over-engineering）
- 定期問：「這個複雜度是必要的嗎？」

### 原則 3：保持願景（Maintain the Vision）

> **清晰的願景是成功的關鍵。沒有願景，系統會變成各種妥協的拼湊。**

每個系統都需要一個「守護者」來維護其概念完整性。

**應用**：
- 有明確的架構願景和設計原則
- 有人負責維護系統的概念完整性
- 新功能要符合整體願景，而非隨意添加

### 原則 4：關注點分離（Separation of Concerns）

> **將系統分解為獨立的部分，每個部分負責一個關注點。**

這是軟體設計最重要的原則之一。

**應用**：
- UI 和業務邏輯分離
- 資料存取和業務邏輯分離
- 不同的業務領域分離

### 原則 5：為變更而設計（Design for Change）

> **軟體會變更。設計時就要考慮：什麼最可能變？如何讓變更容易？**

變更是確定的，問題是什麼會變、何時變。

**應用**：
- 識別最可能變更的部分
- 封裝變化，隔離影響
- 使用介面隔離依賴

### 原則 6：為測試而設計（Design for Test）

> **如果不能測試，就不能確保正確。設計時就要考慮可測試性。**

可測試的程式碼往往也是好的程式碼。

**應用**：
- 依賴注入，方便替換
- 純函數，沒有副作用
- 模組化，可獨立測試

### 原則 7：不要重複（DRY - Don't Repeat Yourself）

> **每一塊知識都應該在系統中有一個、且只有一個、明確的表達。**

重複是錯誤的根源。改了一處忘了另一處，就會產生 bug。

**應用**：
- 抽取共用邏輯
- 單一事實來源（Single Source of Truth）
- 但注意：錯誤的抽象比重複更糟

### 原則 8：盡早且經常驗證（Validate Early and Often）

> **越早發現問題，修復成本越低。**

需求階段的錯誤，修復成本是 1；上線後是 200。

**應用**：
- 需求階段就驗證理解
- 設計階段就審查
- 編碼階段就測試
- 持續整合，頻繁回饋

---

## 6.4 溝通原則

軟體開發本質上是溝通活動——與使用者溝通、與團隊溝通、與未來維護者溝通。

### 原則 1：傾聽（Listen）

> **真正理解對方在說什麼，而不是等待輪到自己說話。**

大多數誤解來自沒有真正傾聽。

**實踐**：
- 複述對方的話以確認理解
- 問澄清問題
- 注意非語言訊息

### 原則 2：準備（Prepare）

> **在溝通前做好準備，才能有效溝通。**

沒有準備的會議是浪費時間。

**實踐**：
- 會議前準備議程和材料
- 需求會議前了解業務領域
- 技術討論前準備方案

### 原則 3：有人推動（Facilitate）

> **有效的溝通需要有人推動，確保溝通發生且有結果。**

沒人推動的溝通往往沒有結論。

**實踐**：
- 會議有主持人
- 討論有時間框
- 結束時確認結論和行動

### 原則 4：面對面（Face-to-Face）

> **面對面溝通是最有效的，但成本也最高。根據情境選擇。**

| 溝通方式 | 頻寬 | 成本 | 適用 |
|----------|------|------|------|
| 面對面 | 最高 | 最高 | 複雜問題、衝突 |
| 視訊 | 高 | 中 | 遠端複雜問題 |
| 電話 | 中 | 低 | 快速澄清 |
| 即時訊息 | 低 | 很低 | 簡單問題 |
| 郵件/文件 | 最低 | 最低 | 需要記錄、非緊急 |

### 原則 5：記錄決策（Document Decisions）

> **重要的決策要記錄，包括決策內容、原因、和替代方案。**

人會忘記，人會離開。記錄讓決策可追溯。

**實踐**：
- ADR（Architecture Decision Record）
- 會議紀錄
- 設計文件

---

## 6.5 規劃原則

### 原則 1：理解範圍（Understand Scope）

> **在規劃前，必須清楚知道要做什麼、不做什麼。**

模糊的範圍導致失控的專案。

**實踐**：
- 明確列出範圍內和範圍外
- 使用者故事和驗收標準
- 定期確認範圍

### 原則 2：包含不確定性（Plan for Uncertainty）

> **計畫必然不準確。好的計畫包含對不確定性的承認和應對。**

**實踐**：
- 用範圍估算，而非精確數字
- 識別風險和應對策略
- 預留緩衝時間

### 原則 3：迭代調整（Iterate）

> **計畫不是一次完成的。隨著了解增加，持續調整。**

**實踐**：
- 滾動式規劃（Rolling Wave Planning）
- 每個迭代結束時更新計畫
- 短期計畫詳細，長期計畫粗略

### 原則 4：追蹤進度（Track Progress）

> **如果不追蹤，就不知道是否偏離。**

**實踐**：
- 可見的進度指標
- 定期檢查點
- 燃盡圖、看板

---

## 6.6 建模原則

### 原則 1：模型的目的是溝通

> **建模不是為了產出文件，而是為了思考和溝通。**

模型應該幫助人理解，而非成為負擔。

**實踐**：
- 只建立必要的模型
- 模型的詳細程度取決於受眾
- 模型可以是草圖，不需要正式

### 原則 2：多視角

> **一個模型無法完整表達系統。使用多個視角的模型。**

如同建築有平面圖、立面圖、剖面圖，軟體需要不同視角的模型。

**實踐**：
- 結構視角（類圖、元件圖）
- 行為視角（序列圖、狀態圖）
- 資料視角（ER 圖、資料流圖）

### 原則 3：抽象層次

> **在適當的抽象層次建模。太細節會迷失，太抽象會空洞。**

**實踐**：
- 先高層次再細節
- 根據受眾調整層次
- 不同目的使用不同層次

### 原則 4：可驗證

> **模型應該可以驗證是否正確反映需求或設計。**

無法驗證的模型是沒有意義的。

**實踐**：
- 需求模型可以用場景驗證
- 設計模型可以用審查驗證
- 模型和程式碼應該一致

---

## 6.7 建構原則

### 原則 1：準備優先

> **在寫程式碼前，確保理解了問題和設計。**

沒有準備就開始寫程式碼，最後會花更多時間修改。

### 原則 2：遵循標準

> **遵循團隊的編碼標準和慣例。**

一致性讓程式碼更容易理解和維護。

### 原則 3：循序漸進

> **小步前進，頻繁驗證。不要一次寫太多程式碼再測試。**

**實踐**：
- TDD：寫一點測試，寫一點程式碼
- 小的 commit
- 頻繁整合

### 原則 4：重構

> **持續改善程式碼結構，不改變外在行為。**

程式碼會腐爛。重構是維持健康的方式。

---

## 6.8 部署原則

### 原則 1：持續可部署

> **軟體應該隨時可以部署到生產環境。**

如果部署是痛苦的，就要更頻繁地部署，直到它不痛苦。

### 原則 2：可回滾

> **每次部署都要有回滾計畫。**

事情會出錯。快速回滾比快速修復更重要。

### 原則 3：可觀測

> **部署後必須能觀測系統狀態。**

**實踐**：
- 日誌
- 監控
- 告警

---

## 6.9 本章總結

### 核心原則速查表

| 類別 | 原則 | 一句話 |
|------|------|--------|
| 通用 | 存在的理由 | 為使用者提供價值 |
| 通用 | KISS | 盡可能簡單 |
| 通用 | 關注點分離 | 一個部分做一件事 |
| 通用 | 為變更設計 | 封裝變化 |
| 通用 | DRY | 不要重複 |
| 通用 | 盡早驗證 | 越早發現越便宜 |
| 溝通 | 傾聽 | 真正理解對方 |
| 溝通 | 記錄決策 | 讓決策可追溯 |
| 規劃 | 包含不確定性 | 計畫必然不準 |
| 建模 | 目的是溝通 | 不是產出文件 |
| 建構 | 循序漸進 | 小步前進，頻繁驗證 |
| 部署 | 持續可部署 | 隨時可以上線 |

### 下一章預告

原則是指導方針，但如何應用到實際的需求工作？下一章我們進入「需求工程」——如何發掘、分析、協商、規範需求？

---

## 延伸思考

1. 在你的工作中，哪個原則最常被違反？為什麼？

2. 「簡單」和「靈活」有時候是衝突的。你如何權衡？

3. 你的團隊有記錄決策的習慣嗎？如果沒有，成本是什麼？

---

*下一章：第7章　需求工程*
