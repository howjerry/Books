# 第11章　元件設計

> 「好的元件像樂高積木——可以獨立理解、可以自由組合、可以重複使用。」

---

## 11.1 什麼是元件？

### 11.1.1 元件的定義

**元件（Component）**：可獨立部署、可替換的軟體單元，提供明確的介面。

元件的特徵：
- **封裝**：隱藏內部實作
- **介面**：定義如何使用
- **可替換**：符合介面就可替換
- **可重用**：可以在不同情境使用

### 11.1.2 元件的層次

```
┌─────────────────────────────────────────┐
│              系統（System）              │
├─────────────────────────────────────────┤
│   ┌─────────┐  ┌─────────┐  ┌─────────┐│
│   │ 子系統  │  │ 子系統  │  │ 子系統  ││
│   │(Subsystem)│(Subsystem)│(Subsystem)││
│   └────┬────┘  └────┬────┘  └────┬────┘│
│        │            │            │     │
│   ┌────┴────┐  ┌────┴────┐  ┌────┴────┐│
│   │  元件   │  │  元件   │  │  元件   ││
│   │(Component)│(Component)│(Component)││
│   └────┬────┘  └────┬────┘  └────┬────┘│
│        │            │            │     │
│   ┌────┴────┐  ┌────┴────┐  ┌────┴────┐│
│   │  類別   │  │  類別   │  │  類別   ││
│   │ (Class) │  │ (Class) │  │ (Class) ││
│   └─────────┘  └─────────┘  └─────────┘│
└─────────────────────────────────────────┘
```

### 11.1.3 元件 vs. 類別

| 面向 | 類別 | 元件 |
|------|------|------|
| 粒度 | 細 | 粗 |
| 部署 | 不獨立 | 可獨立 |
| 介面 | 方法簽章 | 服務介面 |
| 替換 | 較困難 | 較容易 |

---

## 11.2 元件設計原則

### 11.2.1 元件內聚性原則

**REP（Reuse/Release Equivalence Principle）**

> 可重用的粒度等於發布的粒度。

- 一起發布的東西，應該可以一起重用
- 不相關的東西不應該放在同一個元件

**CCP（Common Closure Principle）**

> 會一起改變的類別，應該放在同一個元件。

- SRP 的元件層級版本
- 減少變更時需要重新部署的元件數

**CRP（Common Reuse Principle）**

> 一起使用的類別，應該放在同一個元件。

- 如果只用元件的一部分，不要強迫引入全部
- 避免不必要的依賴

### 11.2.2 元件耦合性原則

**ADP（Acyclic Dependencies Principle）**

> 元件依賴圖中不可有循環。

```
❌ 循環依賴
┌───┐     ┌───┐     ┌───┐
│ A │────►│ B │────►│ C │
└───┘     └───┘     └───┘
  ▲                   │
  └───────────────────┘

✅ 無循環依賴
┌───┐     ┌───┐     ┌───┐
│ A │────►│ B │────►│ C │
└───┘     └───┘     └───┘
```

**解決循環依賴**：
1. 提取共同依賴到新元件
2. 使用依賴反轉（DIP）

**SDP（Stable Dependencies Principle）**

> 依賴方向應該朝向穩定的元件。

穩定 = 不容易改變 = 被很多元件依賴

```
不穩定 ──────► 穩定
(容易變)      (不容易變)
```

**SAP（Stable Abstractions Principle）**

> 穩定的元件應該是抽象的。

- 穩定的元件不容易改變，所以應該是抽象的（介面）
- 不穩定的元件可以是具體的

```
穩定 + 具體 = 痛苦（難改但需要改）
穩定 + 抽象 = 好（不需要改）
不穩定 + 具體 = 好（需要改且容易改）
```

---

## 11.3 元件設計過程

### 11.3.1 識別元件

從需求和架構出發，識別元件：

| 方法 | 說明 |
|------|------|
| **業務能力** | 按業務功能劃分（訂單、庫存、支付） |
| **資料擁有** | 按資料所有權劃分 |
| **使用案例** | 按使用案例群組劃分 |
| **變更頻率** | 常一起改變的放一起 |

### 11.3.2 定義介面

元件透過介面和外界溝通：

```
┌─────────────────────────────────────────┐
│                元件                      │
│                                         │
│  ┌─────────────┐                        │
│  │  提供介面   │◄───── 別人怎麼用我     │
│  │ (Provided)  │                        │
│  └─────────────┘                        │
│                                         │
│  ┌─────────────┐                        │
│  │  需要介面   │◄───── 我需要什麼       │
│  │ (Required)  │                        │
│  └─────────────┘                        │
│                                         │
└─────────────────────────────────────────┘
```

**好介面的特徵**：

| 特徵 | 說明 |
|------|------|
| 簡單 | 只暴露必要的操作 |
| 完整 | 足以完成需要的功能 |
| 穩定 | 不頻繁改變 |
| 一致 | 命名、風格一致 |
| 抽象 | 隱藏實作細節 |

### 11.3.3 設計內部結構

元件內部通常包含：

```
┌─────────────────────────────────────────┐
│                  元件                    │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │           Facade/API             │   │
│  │         (介面實作)                │   │
│  └──────────────┬──────────────────┘   │
│                 │                       │
│  ┌──────────────┼──────────────────┐   │
│  │              ▼                   │   │
│  │  ┌─────────────────────────┐    │   │
│  │  │     Domain/Service      │    │   │
│  │  │      (業務邏輯)          │    │   │
│  │  └────────────┬────────────┘    │   │
│  │               │                  │   │
│  │  ┌────────────┼────────────┐    │   │
│  │  │            ▼            │    │   │
│  │  │  ┌──────────────────┐  │    │   │
│  │  │  │   Repository     │  │    │   │
│  │  │  │   (資料存取)      │  │    │   │
│  │  │  └──────────────────┘  │    │   │
│  │  └─────────────────────────┘    │   │
│  │           內部層次               │   │
│  └─────────────────────────────────┘   │
│                                         │
└─────────────────────────────────────────┘
```

---

## 11.4 常見元件類型

### 11.4.1 服務類元件

```
┌────────────────────────────────┐
│         OrderService           │
├────────────────────────────────┤
│ + createOrder(data): Order     │
│ + getOrder(id): Order          │
│ + cancelOrder(id): void        │
│ + listOrders(filter): Order[]  │
└────────────────────────────────┘
```

特點：
- 無狀態
- 提供業務操作
- 通常是 singleton

### 11.4.2 資料存取元件（Repository）

```
┌────────────────────────────────┐
│     <<interface>>              │
│     OrderRepository            │
├────────────────────────────────┤
│ + save(order): void            │
│ + findById(id): Order          │
│ + findByUser(userId): Order[]  │
│ + delete(id): void             │
└────────────────────────────────┘
         ▲
         │
┌────────┴───────────────────────┐
│     PostgresOrderRepository    │
├────────────────────────────────┤
│ - db: Connection               │
├────────────────────────────────┤
│ + save(order): void            │
│ + findById(id): Order          │
│ ...                            │
└────────────────────────────────┘
```

特點：
- 封裝資料存取邏輯
- 可替換不同實作
- 遵循 DIP

### 11.4.3 領域物件

```
┌────────────────────────────────┐
│             Order              │
├────────────────────────────────┤
│ - id: OrderId                  │
│ - items: OrderItem[]           │
│ - status: OrderStatus          │
│ - totalAmount: Money           │
├────────────────────────────────┤
│ + addItem(item): void          │
│ + removeItem(itemId): void     │
│ + cancel(): void               │
│ + ship(): void                 │
│ - validateInvariants(): void   │
└────────────────────────────────┘
```

特點：
- 包含業務邏輯
- 維護不變量（invariants）
- Rich Domain Model

### 11.4.4 工具類元件

```
┌────────────────────────────────┐
│         EmailSender            │
├────────────────────────────────┤
│ + send(to, subject, body): void│
│ + sendTemplate(to, template,   │
│                context): void  │
└────────────────────────────────┘
```

特點：
- 提供通用功能
- 無業務邏輯
- 可跨元件重用

---

## 11.5 元件間通訊

### 11.5.1 同步通訊

```
┌─────────┐  request   ┌─────────┐
│ 元件 A  │ ─────────► │ 元件 B  │
│         │ ◄───────── │         │
└─────────┘  response  └─────────┘
```

**方式**：
- 方法調用
- REST API
- gRPC

**優點**：簡單、直觀
**缺點**：耦合、等待

### 11.5.2 非同步通訊

```
┌─────────┐  event    ┌─────────────┐  event    ┌─────────┐
│ 元件 A  │ ────────► │  Message    │ ────────► │ 元件 B  │
│         │           │  Queue      │           │         │
└─────────┘           └─────────────┘           └─────────┘
```

**方式**：
- 訊息佇列（RabbitMQ, Kafka）
- 事件匯流排
- Pub/Sub

**優點**：解耦、可擴展
**缺點**：複雜、偵錯難

### 11.5.3 選擇通訊方式

| 情境 | 推薦方式 |
|------|----------|
| 需要即時回應 | 同步 |
| 可以延遲處理 | 非同步 |
| 需要解耦 | 非同步 |
| 簡單操作 | 同步 |
| 長時間處理 | 非同步 |
| 需要保證送達 | 非同步 + 訊息佇列 |

---

## 11.6 元件測試

### 11.6.1 測試層次

```
┌─────────────────────────────────────────┐
│              元件測試                    │
│  (整個元件作為黑箱測試)                  │
├─────────────────────────────────────────┤
│              整合測試                    │
│  (元件內部類別的整合)                    │
├─────────────────────────────────────────┤
│              單元測試                    │
│  (單一類別/函數)                         │
└─────────────────────────────────────────┘
```

### 11.6.2 元件測試策略

**黑箱測試**：只透過公開介面測試

```python
# 元件測試範例
class OrderServiceComponentTest:
    def test_create_order_success(self):
        # Arrange
        order_service = OrderServiceFactory.create()  # 真實元件
        order_data = {"user_id": 1, "items": [...]}

        # Act
        order = order_service.create_order(order_data)

        # Assert
        assert order.id is not None
        assert order.status == "created"
```

**隔離測試**：mock 外部依賴

```python
class OrderServiceIsolatedTest:
    def test_create_order_with_mock(self):
        # Arrange
        mock_repo = MockOrderRepository()
        mock_payment = MockPaymentService()
        order_service = OrderService(mock_repo, mock_payment)

        # Act
        order = order_service.create_order(order_data)

        # Assert
        mock_repo.save.assert_called_once()
```

### 11.6.3 契約測試

確保元件之間的契約一致：

```
┌─────────────┐     契約     ┌─────────────┐
│   消費者    │ ◄──────────► │   提供者    │
│             │              │             │
│ 期望:       │              │ 保證:       │
│ GET /orders │              │ GET /orders │
│ 返回 []     │              │ 返回 []     │
└─────────────┘              └─────────────┘
```

工具：Pact, Spring Cloud Contract

---

## 11.7 本章總結

### 核心概念

| 概念 | 一句話解釋 |
|------|-----------|
| 元件 | 可獨立部署、可替換的軟體單元 |
| REP | 一起發布的才能一起重用 |
| CCP | 一起改變的放在一起 |
| CRP | 一起使用的放在一起 |
| ADP | 依賴圖無循環 |
| SDP | 依賴朝向穩定 |
| SAP | 穩定的應該抽象 |

### 元件設計檢查清單

| 項目 | 問題 |
|------|------|
| 內聚性 | 元件只做一件事嗎？ |
| 耦合性 | 元件之間依賴少嗎？ |
| 介面 | 介面簡單、完整、穩定嗎？ |
| 可替換 | 元件可以替換嗎？ |
| 可測試 | 元件容易測試嗎？ |
| 無循環 | 依賴圖有循環嗎？ |

### 下一章預告

元件設計確定後，使用者如何和系統互動？下一章我們將學習「使用者體驗設計」——UX 設計的原則和實踐。

---

## 延伸思考

1. 你的系統如何劃分元件？根據什麼原則？

2. 元件之間如何通訊？同步還是非同步？

3. 你有測試元件的策略嗎？如何確保元件可替換？

---

*下一章：第12章　使用者體驗設計*
