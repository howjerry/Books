# 第9章　設計的概念

> 「設計是從『問題空間』到『解決方案空間』的橋樑。好的設計不是沒有東西可加，而是沒有東西可減。」

---

## 9.1 什麼是軟體設計？

### 9.1.1 設計的定義

**設計**：將需求轉化為可實作的藍圖。

設計回答的問題：
- **結構**：系統由哪些部分組成？
- **關係**：這些部分如何互動？
- **行為**：系統如何運作？
- **品質**：如何達成非功能需求？

### 9.1.2 設計的層次

```
┌─────────────────────────────────────────┐
│           架構設計                       │
│   (高層次結構、主要元件、品質屬性)        │
├─────────────────────────────────────────┤
│           介面設計                       │
│   (元件之間如何互動、API 設計)           │
├─────────────────────────────────────────┤
│           元件設計                       │
│   (每個元件內部如何運作)                 │
├─────────────────────────────────────────┤
│           資料設計                       │
│   (資料結構、資料庫設計)                 │
└─────────────────────────────────────────┘
```

| 層次 | 關注點 | 產出物 |
|------|--------|--------|
| 架構設計 | 系統結構、品質屬性 | 架構圖、ADR |
| 介面設計 | 元件互動、API | 介面規格、API 文件 |
| 元件設計 | 內部邏輯、演算法 | 類別圖、詳細設計 |
| 資料設計 | 資料結構、持久化 | ER 圖、Schema |

### 9.1.3 設計 vs. 架構

常有混淆，這裡釐清：

| 面向 | 架構 | 設計 |
|------|------|------|
| 範圍 | 系統整體 | 可以是局部 |
| 決策影響 | 難以改變 | 較容易改變 |
| 關注點 | 品質屬性、大方向 | 實作細節 |
| 誰負責 | 架構師 | 開發者/設計師 |

**經驗法則**：如果改變這個決策會影響很多地方，那是架構決策。

---

## 9.2 設計的品質

### 9.2.1 什麼是好的設計？

好的設計應該具備：

| 特性 | 說明 |
|------|------|
| **正確性** | 滿足需求 |
| **可理解性** | 容易理解 |
| **可維護性** | 容易修改 |
| **可測試性** | 容易測試 |
| **效能** | 滿足效能需求 |
| **安全性** | 沒有漏洞 |

### 9.2.2 設計品質指標

**內聚性（Cohesion）**：模組內部的相關程度。

> 高內聚 = 好。模組只做一件事，做得很好。

內聚性由低到高：

| 類型 | 說明 | 品質 |
|------|------|------|
| 偶然內聚 | 沒什麼關係，只是放在一起 | 最差 |
| 邏輯內聚 | 邏輯相似但不相關的功能 | 差 |
| 時間內聚 | 同一時間執行的功能 | 中 |
| 程序內聚 | 按順序執行的功能 | 中 |
| 溝通內聚 | 操作同一資料的功能 | 好 |
| 順序內聚 | 一個的輸出是另一個的輸入 | 好 |
| 功能內聚 | 為一個目的服務的功能 | 最好 |

**耦合性（Coupling）**：模組之間的依賴程度。

> 低耦合 = 好。模組獨立，改一個不會影響其他。

耦合性由高到低：

| 類型 | 說明 | 品質 |
|------|------|------|
| 內容耦合 | 直接存取另一個模組的內部 | 最差 |
| 共享耦合 | 共用全域變數 | 差 |
| 控制耦合 | 傳遞控制旗標 | 中 |
| 標記耦合 | 傳遞資料結構，只用部分 | 中 |
| 資料耦合 | 只傳遞需要的資料 | 好 |
| 訊息耦合 | 只透過訊息溝通 | 最好 |

### 9.2.3 設計原則：SOLID

SOLID 是物件導向設計的五個核心原則：

| 字母 | 原則 | 一句話 |
|------|------|--------|
| S | Single Responsibility | 一個類別只有一個改變的理由 |
| O | Open/Closed | 對擴展開放，對修改關閉 |
| L | Liskov Substitution | 子類別可以替代父類別 |
| I | Interface Segregation | 多個專用介面優於一個通用介面 |
| D | Dependency Inversion | 依賴抽象，不依賴具體 |

**S - 單一責任原則（SRP）**

```
❌ 壞例子
┌────────────────┐
│     User       │
├────────────────┤
│ name           │
│ email          │
├────────────────┤
│ save()         │  ← 儲存邏輯
│ sendEmail()    │  ← 寄信邏輯
│ generateReport │  ← 報表邏輯
└────────────────┘

✅ 好例子
┌────────────────┐  ┌────────────────┐  ┌────────────────┐
│     User       │  │   UserRepo     │  │  EmailService  │
├────────────────┤  ├────────────────┤  ├────────────────┤
│ name           │  │ save(user)     │  │ send(user)     │
│ email          │  │ find(id)       │  └────────────────┘
└────────────────┘  └────────────────┘
```

**O - 開放/關閉原則（OCP）**

```
❌ 壞例子：加新類型要改 switch
function calculateArea(shape) {
  switch (shape.type) {
    case 'circle': return Math.PI * shape.radius ** 2;
    case 'rectangle': return shape.width * shape.height;
    // 加新形狀要改這裡
  }
}

✅ 好例子：加新類型只需加新類別
interface Shape {
  getArea(): number;
}

class Circle implements Shape {
  getArea() { return Math.PI * this.radius ** 2; }
}

class Rectangle implements Shape {
  getArea() { return this.width * this.height; }
}
```

**D - 依賴反轉原則（DIP）**

```
❌ 壞例子：高層模組依賴低層模組
┌────────────────┐
│    Order       │
├────────────────┤
│ mysqlDb: MySQL │  ← 依賴具體類別
├────────────────┤
│ save()         │
└────────────────┘

✅ 好例子：都依賴抽象
┌────────────────┐      ┌────────────────┐
│    Order       │      │  <<interface>> │
├────────────────┤      │   Database     │
│ db: Database   │─────►├────────────────┤
├────────────────┤      │ save(data)     │
│ save()         │      │ find(id)       │
└────────────────┘      └───────▲────────┘
                                │
                    ┌───────────┴───────────┐
                    │                       │
            ┌───────┴───────┐       ┌───────┴───────┐
            │    MySQL      │       │   MongoDB     │
            └───────────────┘       └───────────────┘
```

---

## 9.3 設計概念與技術

### 9.3.1 抽象（Abstraction）

**定義**：隱藏細節，只暴露必要的資訊。

```
┌─────────────────────────────────────────┐
│                  汽車                    │
│    ┌─────────┐  ┌─────────┐            │
│    │   前進   │  │   後退   │   ← 抽象  │
│    └─────────┘  └─────────┘            │
├─────────────────────────────────────────┤
│  引擎、變速箱、油門控制、煞車系統...     │ ← 隱藏的細節
└─────────────────────────────────────────┘
```

**兩種抽象**：

| 類型 | 說明 | 例子 |
|------|------|------|
| 程序抽象 | 隱藏如何做 | 函數、方法 |
| 資料抽象 | 隱藏資料結構 | 類別、介面 |

### 9.3.2 封裝（Encapsulation）

**定義**：將資料和操作資料的方法綁在一起，限制外部存取。

```
❌ 沒有封裝
class User:
    name = ""      # 外部可直接存取
    balance = 0    # 外部可直接修改

# 可能的問題
user.balance = -1000  # 餘額可以是負的？

✅ 有封裝
class User:
    __balance = 0  # 私有

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def withdraw(self, amount):
        if amount > 0 and amount <= self.__balance:
            self.__balance -= amount
```

**好處**：
- 保護資料完整性
- 可以改變內部實作而不影響外部
- 強制通過方法操作，可以加入驗證

### 9.3.3 模組化（Modularity）

**定義**：將系統分解成獨立的模組，每個模組負責特定功能。

**好處**：
- 分工合作
- 獨立測試
- 重複使用
- 局部修改

**模組化的指標**：
- 高內聚
- 低耦合
- 明確的介面

### 9.3.4 資訊隱藏（Information Hiding）

**定義**：每個模組隱藏設計決策，只透過介面溝通。

> 「問模組能做什麼，不問它怎麼做。」

**隱藏什麼？**
- 演算法選擇
- 資料結構
- 資源管理
- 硬體相關細節

### 9.3.5 關注點分離（Separation of Concerns）

**定義**：將系統分成不同的部分，每個部分負責一個關注點。

常見的分離：

| 分離 | 例子 |
|------|------|
| UI vs. 業務邏輯 | MVC、MVVM |
| 領域 vs. 基礎設施 | Clean Architecture |
| 核心 vs. 橫切關注 | AOP（日誌、安全） |
| 讀 vs. 寫 | CQRS |

---

## 9.4 設計模式簡介

### 9.4.1 什麼是設計模式？

**設計模式**：對常見問題的可重用解決方案。

設計模式的結構：
- **名稱**：溝通的詞彙
- **問題**：什麼情境下使用
- **解決方案**：如何解決
- **結果**：權衡和後果

### 9.4.2 常見設計模式分類

| 類別 | 目的 | 例子 |
|------|------|------|
| 創建型 | 物件如何建立 | Factory, Singleton, Builder |
| 結構型 | 物件如何組合 | Adapter, Decorator, Facade |
| 行為型 | 物件如何互動 | Strategy, Observer, Command |

### 9.4.3 幾個常用模式

**Strategy（策略模式）**

```
問題：有多種演算法，需要動態切換

┌─────────────────┐      ┌─────────────────┐
│     Context     │      │  <<interface>>  │
├─────────────────┤      │    Strategy     │
│ strategy        │─────►├─────────────────┤
├─────────────────┤      │ execute()       │
│ doSomething()   │      └────────▲────────┘
└─────────────────┘               │
                      ┌───────────┼───────────┐
                      │           │           │
              ┌───────┴───┐ ┌─────┴─────┐ ┌───┴───────┐
              │ StrategyA │ │ StrategyB │ │ StrategyC │
              └───────────┘ └───────────┘ └───────────┘
```

**Factory（工廠模式）**

```
問題：建立物件的邏輯複雜，或需要根據條件建立不同類型

┌─────────────────┐
│    Factory      │
├─────────────────┤
│ create(type)    │───► 根據 type 返回不同的物件
└─────────────────┘

使用：
product = Factory.create("typeA")  // 不需要知道具體類別
```

**Observer（觀察者模式）**

```
問題：一個物件狀態改變時，需要通知多個其他物件

┌─────────────────┐      ┌─────────────────┐
│    Subject      │      │  <<interface>>  │
├─────────────────┤      │    Observer     │
│ observers[]     │      ├─────────────────┤
├─────────────────┤      │ update(data)    │
│ attach(obs)     │      └────────▲────────┘
│ detach(obs)     │               │
│ notify()        │───────────────┘
└─────────────────┘
```

---

## 9.5 設計的過程

### 9.5.1 從需求到設計

```
需求 → 架構設計 → 介面設計 → 元件設計 → 資料設計
        ↑                                    │
        └────────── 迭代 ───────────────────┘
```

### 9.5.2 設計活動

| 活動 | 輸入 | 輸出 |
|------|------|------|
| 架構設計 | 需求、品質屬性 | 架構圖、ADR |
| 介面設計 | 架構、使用案例 | API 規格 |
| 元件設計 | 介面、功能需求 | 類別圖、演算法 |
| 資料設計 | 元件設計、資料需求 | ER 圖、Schema |
| 審查 | 設計文件 | 審查報告 |

### 9.5.3 設計審查

設計審查的檢查點：

| 項目 | 問題 |
|------|------|
| 正確性 | 設計能滿足所有需求嗎？ |
| 完整性 | 有遺漏的功能嗎？ |
| 一致性 | 設計各部分一致嗎？ |
| 可行性 | 技術上可行嗎？ |
| 效能 | 能達到效能需求嗎？ |
| 安全性 | 有安全漏洞嗎？ |
| 可維護性 | 容易修改嗎？ |
| 可測試性 | 容易測試嗎？ |

---

## 9.6 本章總結

### 核心概念

| 概念 | 一句話解釋 |
|------|-----------|
| 設計 | 從需求到實作的藍圖 |
| 內聚性 | 模組內部的相關程度（高好） |
| 耦合性 | 模組之間的依賴程度（低好） |
| SOLID | 物件導向設計的五個核心原則 |
| 抽象 | 隱藏細節，只暴露必要資訊 |
| 封裝 | 資料和方法綁在一起，限制存取 |
| 模組化 | 分解成獨立模組 |
| 設計模式 | 常見問題的可重用解決方案 |

### 設計原則速查表

| 原則 | 說明 |
|------|------|
| 高內聚 | 模組只做一件事 |
| 低耦合 | 模組之間依賴少 |
| KISS | 保持簡單 |
| DRY | 不重複 |
| SRP | 單一責任 |
| OCP | 對擴展開放，對修改關閉 |
| DIP | 依賴抽象 |
| 資訊隱藏 | 隱藏實作細節 |
| 關注點分離 | 不同關注點分開 |

### 下一章預告

設計概念理解後，如何進行架構設計？下一章我們將學習「架構設計的推薦方法」——架構風格、品質屬性、架構決策。

---

## 延伸思考

1. 你的程式碼有高內聚、低耦合嗎？如何評估？

2. SOLID 原則中，哪個對你最有用？哪個最難應用？

3. 你有使用設計模式嗎？是否有過度使用的情況？

---

*下一章：第10章　架構設計的推薦方法*
