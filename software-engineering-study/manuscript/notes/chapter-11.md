# 第11章　元件設計 — 學習筆記

> **狀態**：✅ 已完成
> **閱讀日期**：2025-12-27
> **教材位置**：[content/chapter-11.md](../content/chapter-11.md)

---

## 章前預測（5 分鐘）

### 這章應該回答什麼問題？

1. 什麼是元件？和類別有什麼不同？
2. 元件設計有哪些原則？
3. 如何識別和劃分元件？
4. 元件之間如何通訊？

### 我現在的理解是什麼？

閱讀前，我的理解：
- 元件就是一群類別
- 元件劃分靠直覺
- 所有元件通訊都用 API

### 我遇過哪些相關痛點？

1. **元件邊界模糊**：不知道這個功能該放哪個元件
2. **循環依賴**：A 依賴 B，B 又依賴 A
3. **改一個元件影響很多**：元件之間耦合太緊

---

## 本章一句話

> **好的元件像樂高積木——可以獨立理解、可以自由組合、可以重複使用。元件劃分要遵循內聚性原則（CCP、CRP）和耦合性原則（ADP、SDP、SAP）。**

---

## 3 個關鍵概念

### 概念 1：元件內聚性原則

**書中定義**：

三個內聚性原則：
- **REP**：一起發布的才能一起重用
- **CCP**：會一起改變的放在一起（減少變更影響）
- **CRP**：一起使用的放在一起（避免不必要依賴）

**我的理解**：

這三個原則指導「什麼類別應該放在同一個元件」。

**CCP 最實用**：
- 問：「如果 X 改變，還有什麼會跟著改？」
- 把會一起改的放在一起
- 這樣每次變更只需要部署一個元件

**CRP 避免浪費**：
- 問：「使用者只用元件的一部分嗎？」
- 如果是，考慮拆分
- 避免引入不需要的依賴

**例子**：

```
❌ 違反 CCP
┌─────────────────────┐
│    UserComponent    │
├─────────────────────┤
│ UserProfile         │  ← 常改變
│ UserAuthentication  │  ← 很少改變
│ UserNotification    │  ← 獨立改變
└─────────────────────┘

✅ 遵循 CCP
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│ ProfileComponent│  │  AuthComponent  │  │NotifyComponent  │
├─────────────────┤  ├─────────────────┤  ├─────────────────┤
│ UserProfile     │  │ Authentication  │  │ Notification    │
│ ProfileEditor   │  │ LoginService    │  │ NotifyService   │
└─────────────────┘  └─────────────────┘  └─────────────────┘
```

---

### 概念 2：元件耦合性原則

**書中定義**：

三個耦合性原則：
- **ADP**：依賴圖中不可有循環
- **SDP**：依賴方向朝向穩定
- **SAP**：穩定的元件應該是抽象的

**我的理解**：

**ADP 是底線**：
- 循環依賴 = 災難
- A 依賴 B，B 依賴 A → 改任何一個都要改另一個
- 解法：提取共同依賴、依賴反轉

**SDP + SAP 一起用**：
- 穩定 = 被很多人依賴 = 不容易改
- 穩定的元件如果是具體的 → 痛苦（需要改但改不了）
- 穩定的元件應該是抽象的（介面）→ 可以改實作

**依賴方向**：

```
不穩定 ──────► 穩定
具體實作       抽象介面
容易改         不需要改
```

**例子**：

```
┌─────────────────┐
│  OrderService   │ ← 不穩定（業務邏輯常變）
└────────┬────────┘
         │ 依賴
         ▼
┌─────────────────┐
│ <<interface>>   │ ← 穩定（介面不變）
│ PaymentGateway  │
└────────▲────────┘
         │ 實作
┌────────┴────────┐
│ StripePayment   │ ← 不穩定（可以換）
└─────────────────┘
```

---

### 概念 3：元件間通訊選擇

**書中定義**：

| 方式 | 特點 | 適用 |
|------|------|------|
| 同步 | 等待回應、簡單 | 需要即時回應 |
| 非同步 | 不等待、解耦 | 可延遲、需解耦 |

**我的理解**：

**預設同步**，在這些情況用非同步：
1. 處理時間長（> 幾秒）
2. 不需要即時結果
3. 需要解耦（生產者不關心消費者）
4. 需要削峰填谷（處理突發流量）

**非同步的成本**：
- 複雜度增加
- 偵錯困難
- 需要處理訊息失敗
- 最終一致性

**經驗法則**：
> 「先用同步，在痛的時候再改非同步。」

---

## 原則、方法、護欄

### 元件設計原則速查表

| 原則 | 問題 | 指導 |
|------|------|------|
| CCP | 什麼放在一起？ | 一起改變的放一起 |
| CRP | 什麼不放在一起？ | 不一起使用的分開 |
| ADP | 依賴方向？ | 無循環 |
| SDP | 依賴誰？ | 朝向穩定 |
| SAP | 穩定元件長什麼樣？ | 抽象（介面） |

---

### 護欄（Guardrail）

| 危險信號 | 可能的問題 | 修正方式 |
|----------|-----------|----------|
| 元件太大 | 內聚性低 | 按 CCP/CRP 拆分 |
| 循環依賴 | 違反 ADP | 提取共同依賴、DIP |
| 改一個元件影響很多 | 耦合太高 | 檢查依賴方向（SDP） |
| 穩定元件常改 | 違反 SAP | 抽取介面 |
| 元件太多太碎 | 過度設計 | 合併相關元件 |

---

## 1 個決策點

### 決策情境

**同步 vs 非同步通訊：什麼時候用哪個？**

### 選項對比

| 面向 | 同步 | 非同步 |
|------|------|--------|
| 複雜度 | 低 | 高 |
| 等待 | 需要 | 不需要 |
| 耦合 | 較高 | 較低 |
| 偵錯 | 容易 | 困難 |
| 即時性 | 即時 | 延遲 |

### 決策準則

**用同步**：
- 需要立即結果
- 操作簡單快速（< 1 秒）
- 元件在同一服務內
- 團隊不熟悉訊息佇列

**用非同步**：
- 處理時間長
- 不需要即時結果
- 需要解耦生產者和消費者
- 需要處理突發流量
- 需要保證送達

---

## 1 個反模式（Anti-pattern）

### 反模式名稱

**「萬能元件」症候群**（God Component）

### 錯誤做法

一個元件包含太多功能：
- UserComponent 包含使用者管理、認證、權限、通知
- 幾十個類別、幾萬行程式碼
- 改任何功能都要部署這個元件

### 後果

1. **難以理解**：太大，沒人能完全理解
2. **難以修改**：改一處可能影響其他
3. **難以測試**：測試涵蓋太廣
4. **難以部署**：改小功能要部署大元件
5. **團隊衝突**：多人改同一個元件

### 正確做法

1. **按 CCP 拆分**：一起改變的放一起
2. **明確責任**：每個元件只做一件事
3. **大小適中**：一個元件 5-10 個類別
4. **清晰邊界**：介面簡單明確

**檢驗標準**：
> 「這個元件可以用一句話描述嗎？」
> 「新人能在一天內理解這個元件嗎？」

---

## 可落地 Checklist（至少 5 條）

元件設計時用這份清單：

- [x] **單一責任**：元件只做一件事嗎？
- [x] **CCP 檢查**：一起改變的放在一起了嗎？
- [x] **CRP 檢查**：有沒有不必要的依賴？
- [x] **ADP 檢查**：有循環依賴嗎？
- [x] **SDP 檢查**：依賴方向朝向穩定嗎？
- [x] **介面清晰**：介面簡單、完整嗎？
- [x] **可測試**：元件容易獨立測試嗎？

---

## 章後練習

### 練習：分析一個元件的設計問題

> 情境：一個「UserComponent」包含以下類別

```
UserComponent/
├── User.java              # 使用者實體
├── UserRepository.java    # 使用者資料存取
├── UserService.java       # 使用者業務邏輯
├── LoginService.java      # 登入邏輯
├── PasswordEncoder.java   # 密碼加密
├── SessionManager.java    # 會話管理
├── RoleService.java       # 角色權限
├── Permission.java        # 權限定義
├── EmailNotifier.java     # 郵件通知
├── SmsNotifier.java       # 簡訊通知
└── AuditLogger.java       # 審計日誌
```

**問題分析**：

| 問題 | 違反的原則 |
|------|-----------|
| 使用者管理和認證混在一起 | CCP（不一起改變） |
| 通知功能和使用者混在一起 | CRP（不一起使用） |
| 審計功能和使用者混在一起 | CCP/CRP |

**改善建議**：

```
拆分成 4 個元件：

UserComponent/
├── User.java
├── UserRepository.java
└── UserService.java

AuthComponent/
├── LoginService.java
├── PasswordEncoder.java
├── SessionManager.java
├── RoleService.java
└── Permission.java

NotificationComponent/
├── EmailNotifier.java
├── SmsNotifier.java
└── NotificationService.java

AuditComponent/
└── AuditLogger.java
```

**改善後的好處**：
- 改使用者邏輯不影響認證
- 改通知不需要重新部署使用者元件
- 每個元件可以獨立測試和部署

---

## 延伸思考

### 你的系統有循環依賴嗎？如何解決？

**我的思考**：

常見的循環依賴場景：
1. A 呼叫 B，B 呼叫 A
2. 雙向導航（Order 有 User，User 有 Orders）

**解決方法**：

1. **提取共同依賴**：
   ```
   A ← Common → B
   ```

2. **依賴反轉**：
   ```
   A → Interface ← B
   ```

3. **事件解耦**：
   ```
   A → Event Bus → B
   ```

4. **單向導航**：
   ```
   Order → User（User 不直接引用 Order）
   ```

### 你如何決定元件的大小？

**我的經驗法則**：

1. **可理解**：新人一天內能理解
2. **可描述**：一句話能說清楚責任
3. **可測試**：可以獨立測試
4. **可部署**：變更只影響這個元件

**具體指標**：
- 5-15 個類別
- 1000-5000 行程式碼
- 3-5 個公開 API

---

## 完成確認

- [x] 完成章前預測
- [x] 讀完本章
- [x] 填寫本章一句話
- [x] 填寫 3 個關鍵概念
- [x] 填寫原則、方法、護欄
- [x] 填寫 1 個決策點
- [x] 填寫 1 個反模式
- [x] 填寫 Checklist
- [x] 完成章後練習
- [x] 完成延伸思考

**完成日期**：2025-12-27
