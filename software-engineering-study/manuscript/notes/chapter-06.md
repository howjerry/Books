# 第6章　作為實務指引的原則 — 學習筆記

> **狀態**：✅ 已完成
> **閱讀日期**：2025-12-27
> **教材位置**：[content/chapter-06.md](../content/chapter-06.md)

---

## 章前預測（5 分鐘）

### 這章應該回答什麼問題？

1. 為什麼需要原則？原則和實踐有什麼差別？
2. 有哪些核心的軟體工程原則？
3. 這些原則如何指導日常實踐？
4. 不同階段（溝通、規劃、建模、建構、部署）有什麼特定原則？

### 我現在的理解是什麼？

閱讀前，我的理解：
- SOLID、DRY、KISS 這些原則我聽過
- 但不太確定如何系統性地理解和應用

### 我遇過哪些相關痛點？

1. **過度設計**：為了「靈活」而複雜化，結果沒人用到那些靈活性
2. **重複程式碼**：知道 DRY，但有時候抽象更糟糕
3. **決策不可追溯**：不知道當初為什麼這樣設計

---

## 本章一句話

> **原則是『為什麼』的答案，實踐是『怎麼做』的答案。實踐會變，原則相對穩定。理解原則，才能在新情境中創造適合的實踐。**

---

## 3 個關鍵概念

### 概念 1：原則 vs. 實踐

**書中定義**：

| 層次 | 特徵 | 例子 |
|------|------|------|
| 實踐 | 具體做法，情境依賴 | Scrum、TDD、Code Review |
| 原則 | 抽象指導，相對穩定 | 關注點分離、快速回饋、簡單 |

實踐會過時，原則相對穩定。

**我的理解**：

這解釋了為什麼學「最新的框架」永遠追不完——因為框架是實踐層面的，會不斷變化。

但如果我理解原則：
- 可以評估新實踐是否有價值（它符合什麼原則？）
- 可以在新情境創造適合的實踐
- 可以解釋為什麼某些做法有效

**例子**：
- TDD 是實踐，背後的原則是「盡早驗證」和「快速回饋」
- 如果情境不適合 TDD，但原則仍然適用，我可以找到其他方式實現「盡早驗證」

---

### 概念 2：KISS — 簡單的價值

**書中定義**：

> 所有設計應該盡可能簡單，但不能更簡單。

複雜是軟體的大敵。每增加一分複雜度，就增加一分出錯的機會。

**我的理解**：

這是我最常違反的原則。我經常為了「未來可能的需求」而增加複雜度。

**YAGNI（You Ain't Gonna Need It）** 是 KISS 的延伸：
- 不要為了假設的未來需求而設計
- 等到真正需要時再加

**但要注意**：
- 簡單 ≠ 容易（Simple ≠ Easy）
- 簡單的設計可能需要更多思考
- 有時候需要重構才能變得簡單

**檢驗標準**：「如果我刪掉這個，會怎樣？」

---

### 概念 3：關注點分離

**書中定義**：

> 將系統分解為獨立的部分，每個部分負責一個關注點。

這是軟體設計最重要的原則之一。

**我的理解**：

這個原則解釋了為什麼 MVC、分層架構、微服務等模式存在——它們都是實現「關注點分離」的方式。

**好處**：
- 每個部分更容易理解（只需關注一件事）
- 更容易修改（改動局部化）
- 更容易測試（可以獨立測試）
- 更容易並行開發（不同人負責不同部分）

**常見的分離**：
- UI vs. 業務邏輯 vs. 資料存取
- 核心功能 vs. 跨切關注（日誌、安全、快取）
- 不同業務領域

**檢驗標準**：「這個模組/類別/函數負責幾件事？」

---

## 原則、方法、護欄

### 原則速查表

| 類別 | 原則 | 適用情境 | 一句話 |
|------|------|----------|--------|
| 通用 | 存在的理由 | 功能取捨、技術選型 | 為使用者提供價值 |
| 通用 | KISS | 設計決策 | 盡可能簡單 |
| 通用 | 關注點分離 | 架構設計、模組劃分 | 一個部分做一件事 |
| 通用 | 為變更設計 | 設計時 | 封裝可能變化的部分 |
| 通用 | DRY | 發現重複時 | 單一事實來源 |
| 通用 | 盡早驗證 | 規劃驗證時機 | 越早發現越便宜 |
| 溝通 | 傾聽 | 需求蒐集、會議 | 真正理解對方 |
| 溝通 | 記錄決策 | 重要決策後 | 讓決策可追溯 |
| 規劃 | 包含不確定性 | 估算時 | 計畫必然不準 |
| 建模 | 目的是溝通 | 建模時 | 不是產出文件 |
| 建構 | 循序漸進 | 寫程式碼時 | 小步前進，頻繁驗證 |
| 部署 | 持續可部署 | 部署流程設計 | 隨時可以上線 |

---

### 護欄（Guardrail）

| 危險信號 | 違反的原則 | 修正方式 |
|----------|-----------|----------|
| 「這個功能很酷」但沒人用 | 存在的理由 | 問「對使用者的價值是什麼」 |
| 「以後可能需要」的複雜設計 | KISS、YAGNI | 等真正需要時再加 |
| 一個類別 1000+ 行 | 關注點分離 | 拆分責任 |
| 改一個地方壞了五個地方 | 為變更設計 | 封裝變化、加測試 |
| 到處都有同樣的邏輯 | DRY | 抽取共用，但注意抽象品質 |
| 上線後才發現大問題 | 盡早驗證 | 左移測試、頻繁 Demo |
| 「我以為你的意思是...」 | 傾聽 | 確認理解 |
| 「當初為什麼這樣設計？」 | 記錄決策 | ADR、設計文件 |

---

## 1 個決策點

### 決策情境

**DRY vs. 錯誤抽象：什麼時候該抽取共用？**

### 選項對比

| 選項 | 情境 | 優點 | 缺點 |
|------|------|------|------|
| 抽取共用 | 邏輯真的相同、變更會一起變 | 減少重複、單一來源 | 可能過早抽象 |
| 保持重複 | 只是剛好相似、可能分別演化 | 保持獨立、靈活 | 可能真的重複 |

### 決策準則

**抽取共用**：
- 相同的邏輯出現 3 次以上（Rule of Three）
- 變更時會一起變
- 抽象有清晰的名稱和意義

**保持重複**：
- 只是剛好相似，不是真的相同
- 可能會分別演化
- 抽象會變得很彆扭

**經驗法則**：「重複 > 錯誤的抽象」—— 寧可重複也不要過早抽象。等模式清晰後再抽取。

---

## 1 個反模式（Anti-pattern）

### 反模式名稱

**「未來證明」症候群**（Future-Proofing）

### 錯誤做法

為了「未來可能的需求」而增加複雜度：
- 「萬一以後要換資料庫，所以加一層抽象」
- 「萬一以後需要插件系統，所以先設計好」
- 「萬一以後流量大增，所以先做微服務」

### 後果

1. **增加複雜度**：當前就要維護不需要的東西
2. **猜錯方向**：未來需求往往和猜想不同
3. **延遲交付**：花時間在不確定的事情上
4. **技術債**：過早的抽象往往是錯誤的抽象

### 正確做法

1. **YAGNI**：你不會需要它，等真正需要時再加
2. **簡單開始**：用最簡單的方案解決當前問題
3. **保持可改**：程式碼乾淨、有測試，需要時容易改
4. **漸進式架構**：讓架構隨需求演進

---

## 可落地 Checklist（至少 5 條）

設計和開發時，用這份清單檢驗：

- [x] **價值**：這個功能對使用者有什麼價值？
- [x] **簡單**：這是最簡單的解決方案嗎？能更簡單嗎？
- [x] **職責**：這個模組/類別只負責一件事嗎？
- [x] **變更**：最可能變的部分封裝好了嗎？
- [x] **重複**：有重複的邏輯嗎？該抽取嗎？
- [x] **驗證**：怎麼知道這是對的？測試了嗎？
- [x] **可追溯**：重要決策記錄了嗎？

---

## 章後練習

### 練習：評估最近的設計決策

> 回想最近一個設計決策，用原則評估

| 決策 | 符合的原則 | 違反的原則 | 改善方向 |
|------|-----------|-----------|----------|
| 為「未來擴展」加了抽象層 | 為變更設計（部分） | KISS、YAGNI | 等真正需要時再加 |
| 複製貼上了一段邏輯 | 無 | DRY | 評估是否真的相同，考慮抽取 |
| 做了 ADR 記錄架構決策 | 記錄決策 | 無 | 繼續保持 |

---

## 延伸思考

### 「簡單」和「靈活」有時候是衝突的。你如何權衡？

**我的思考**：

這是一個常見的權衡。我的原則是：

1. **預設簡單**：沒有明確需求時，選擇簡單
2. **靈活有成本**：靈活性的複雜度是現在就要付出的
3. **變更有信號**：真正需要靈活時，需求會告訴你
4. **保持可改**：簡單的程式碼更容易在需要時變靈活

**例子**：
- 不要為了「未來可能換資料庫」而現在就加抽象層
- 但如果真的有多個資料庫的需求，那就該抽象

### 你的團隊有記錄決策的習慣嗎？如果沒有，成本是什麼？

**我的思考**：

我們沒有系統性地記錄決策，成本包括：

1. **重複討論**：同樣的問題討論多次
2. **錯誤重構**：不知道當初的權衡，重構引入問題
3. **新人困惑**：為什麼這樣設計？沒人記得
4. **責任不清**：誰做的決定？為什麼？

**改善**：
- 開始用 ADR 記錄重要架構決策
- 格式簡單：背景、決策、原因、後果
- 放在程式碼庫中，隨程式碼版本控制

---

## 完成確認

- [x] 完成章前預測
- [x] 讀完本章
- [x] 填寫本章一句話
- [x] 填寫 3 個關鍵概念
- [x] 填寫原則、方法、護欄
- [x] 填寫 1 個決策點
- [x] 填寫 1 個反模式
- [x] 填寫 Checklist
- [x] 完成章後練習
- [x] 完成延伸思考

**完成日期**：2025-12-27
