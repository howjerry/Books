# 第19章　軟體測試——元件層級 — 學習筆記

> **狀態**：✅ 已完成
> **閱讀日期**：2025-12-27
> **教材位置**：[content/chapter-19.md](../content/chapter-19.md)

---

## 章前預測（5 分鐘）

### 這章應該回答什麼問題？

1. 什麼是單元測試？為什麼重要？
2. TDD 是什麼？怎麼做？
3. 測試設計有哪些技術？
4. 測試替身是什麼？何時使用？

### 我現在的理解是什麼？

閱讀前，我的理解：
- 單元測試 = 測函式
- 覆蓋率越高越好
- TDD 太慢，實際工作用不了

### 我遇過哪些相關痛點？

1. **測試難維護**：改程式碼要改一堆測試
2. **不知道測什麼**：測了但還是有 bug
3. **測試太慢**：跑完要好幾分鐘

---

## 本章一句話

> **單元測試驗證最小可測試單元的正確性。使用 TDD（Red-Green-Refactor）循環，結合等價類別、邊界值分析設計測試案例，用測試替身隔離外部依賴。遵循 FIRST 原則確保測試品質。**

---

## 3 個關鍵概念

### 概念 1：TDD 循環

**書中定義**：

```
Red → Green → Refactor → 重複
```

1. **Red**：寫一個失敗的測試
2. **Green**：寫最少的程式碼讓測試通過
3. **Refactor**：重構程式碼

**我的理解**：

TDD 改變了我對「測試」的認知。

**以前**：寫完程式碼再補測試（事後驗證）
**TDD**：先寫測試再寫程式碼（設計工具）

**好處**：
- 迫使你思考介面設計
- 每個功能都有測試
- 小步前進，降低風險

**實際體驗**：

```
1. 想清楚「我要什麼結果」→ 寫測試
2. 用最簡單的方式讓測試通過
3. 看著綠燈，安心重構
4. 重複
```

**經驗法則**：
> 「如果你不知道怎麼測試一個功能，代表你還沒想清楚這個功能。」

---

### 概念 2：測試設計技術

**書中定義**：

| 技術 | 用途 |
|------|------|
| 等價類別劃分 | 減少測試數量 |
| 邊界值分析 | 找出邊界問題 |
| 決策表 | 處理條件組合 |
| 狀態轉換 | 測試狀態機 |

**我的理解**：

這些技術幫助「聰明地測」，不是「盲目地測」。

**等價類別 + 邊界值範例**：

驗證年齡（18-65 歲有效）：

| 類別 | 邊界值 |
|------|--------|
| 無效（太小） | 17 |
| 有效邊界 | 18 |
| 有效中間 | 30 |
| 有效邊界 | 65 |
| 無效（太大） | 66 |

**只測 5 個值，就能覆蓋所有情況**。

**經驗法則**：
> 「邊界附近是 bug 最多的地方。」

---

### 概念 3：FIRST 原則

**書中定義**：

| 原則 | 說明 |
|------|------|
| **F**ast | 快速（毫秒級） |
| **I**ndependent | 獨立（測試間不依賴） |
| **R**epeatable | 可重複（任何環境都能跑） |
| **S**elf-validating | 自我驗證（通過或失敗） |
| **T**imely | 及時（和程式碼同時寫） |

**我的理解**：

這五個原則可以用來評估測試品質。

**常見違反**：

| 原則 | 違反情況 | 修正 |
|------|----------|------|
| Fast | 測試連真實 DB | 用 In-Memory DB |
| Independent | 測試 A 依賴測試 B | 每個測試自己準備資料 |
| Repeatable | 依賴當前時間 | 注入 Clock |
| Self-validating | 需要人工檢查 log | 加 assert |
| Timely | 程式碼寫完才補測試 | TDD |

**自我檢查**：
> 「這個測試能在任何時間、任何環境、獨立跑完嗎？」

---

## 原則、方法、護欄

### 單元測試速查表

| 情境 | 技術 | 說明 |
|------|------|------|
| 輸入有範圍 | 等價類別 + 邊界值 | 測邊界和代表值 |
| 多條件組合 | 決策表 | 列出所有組合 |
| 有狀態轉換 | 狀態測試 | 測轉換和非法轉換 |
| 有外部依賴 | 測試替身 | Stub/Mock 隔離 |

---

### 護欄（Guardrail）

| 危險信號 | 可能的問題 | 修正方式 |
|----------|-----------|----------|
| 測試跑很慢 | 連真實 DB/API | 用替身 |
| 改程式碼要改很多測試 | 測試太細節 | 測行為不測實作 |
| 覆蓋率高但還有 bug | 沒測邊界 | 加邊界值測試 |
| 測試順序影響結果 | 測試不獨立 | 每個測試獨立準備 |
| 不知道測試在測什麼 | 命名不清 | 改善命名 |

---

## 1 個決策點

### 決策情境

**要做多少測試替身？**

### 選項對比

| 策略 | 優點 | 缺點 |
|------|------|------|
| 全部用替身 | 快、隔離 | 可能和真實行為不同 |
| 全部用真實 | 真實 | 慢、不穩定 |
| 混合 | 平衡 | 需要判斷 |

### 決策準則

| 依賴類型 | 建議 |
|----------|------|
| 外部 API | 一定用替身 |
| 資料庫 | 用 In-Memory 或替身 |
| 檔案系統 | 用替身或臨時檔案 |
| 時間 | 注入 Clock |
| 隨機 | 注入 Random |

**經驗法則**：
> 「外部依賴用替身，自己的程式碼儘量用真實。」

---

## 1 個反模式（Anti-pattern）

### 反模式名稱

**「測試實作細節」症候群**

### 錯誤做法

測試綁定實作細節：

```python
# ❌ 測試實作細節
def test_add_item():
    cart = ShoppingCart()
    cart.add_item(item)

    # 綁定私有方法
    assert cart._items[0] == item

    # 驗證呼叫次數
    mock.assert_called_exactly_once()
```

### 後果

1. **脆弱測試**：重構就壞
2. **維護成本**：改程式要改測試
3. **阻礙重構**：不敢改程式碼
4. **假安全感**：測試通過但行為錯

### 正確做法

**測試行為，不測實作**：

```python
# ✅ 測試行為
def test_add_item():
    cart = ShoppingCart()
    cart.add_item(item)

    # 測試公開行為
    assert cart.item_count() == 1
    assert cart.total() == item.price
```

**檢驗標準**：
> 「如果我重構程式碼（不改行為），這個測試會壞嗎？」

---

## 可落地 Checklist（至少 5 條）

寫單元測試時檢查：

- [x] **FIRST 原則**：快速、獨立、可重複、自驗證、及時？
- [x] **AAA 結構**：Arrange-Act-Assert 清楚嗎？
- [x] **邊界值**：邊界測了嗎？
- [x] **替身使用**：外部依賴有隔離嗎？
- [x] **命名清楚**：從名稱能知道測什麼嗎？
- [x] **測行為**：測的是行為還是實作細節？
- [x] **一個測試一個概念**：每個測試只測一件事？

---

## 章後練習

### 練習：用 TDD 實作一個功能

> 目標：用 TDD 實作計算購物車折扣

**需求**：
- 金額 < 500：無折扣
- 金額 500-999：5% 折扣
- 金額 >= 1000：10% 折扣
- VIP 額外 5% 折扣

**Step 1: Red**

```python
def test_no_discount_for_small_amount():
    cart = ShoppingCart()
    cart.add_item(Item("A", 100))
    assert cart.final_price() == 100  # 無折扣
```

**Step 2: Green**

```python
class ShoppingCart:
    def final_price(self):
        return sum(item.price for item in self.items)
```

**Step 3: 下一個測試**

```python
def test_5_percent_for_medium_amount():
    cart = ShoppingCart()
    cart.add_item(Item("A", 600))
    assert cart.final_price() == 570  # 5% off
```

**Step 4: 實作折扣邏輯**

```python
def final_price(self):
    total = sum(item.price for item in self.items)
    if total >= 1000:
        return total * 0.9
    elif total >= 500:
        return total * 0.95
    return total
```

**繼續 TDD 循環...**

---

## 延伸思考

### 你的團隊為什麼不做 TDD？

**常見理由和反駁**：

| 理由 | 反駁 |
|------|------|
| 「太慢」 | 長期來看更快（減少 debug 時間） |
| 「不知道怎麼寫」 | 練習！從簡單功能開始 |
| 「需求一直變」 | 有測試才敢改 |
| 「主管不允許」 | 展示效益給主管看 |

### 如何提高測試品質？

**我的策略**：

1. **Mutation Testing**
   - 故意改程式碼，看測試會不會失敗
   - 如果測試還是過 = 測試沒用

2. **Code Review 看測試**
   - 測試也要 Review
   - 問「這個測試測了什麼？」

3. **測試命名規範**
   - `test_[功能]_[情境]_[預期]`
   - 從名稱就知道測什麼

4. **定期清理**
   - 刪除沒用的測試
   - 合併重複的測試

---

## 完成確認

- [x] 完成章前預測
- [x] 讀完本章
- [x] 填寫本章一句話
- [x] 填寫 3 個關鍵概念
- [x] 填寫原則、方法、護欄
- [x] 填寫 1 個決策點
- [x] 填寫 1 個反模式
- [x] 填寫 Checklist
- [x] 完成章後練習
- [x] 完成延伸思考

**完成日期**：2025-12-27
