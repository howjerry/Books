# 第9章　設計的概念 — 學習筆記

> **狀態**：✅ 已完成
> **閱讀日期**：2025-12-27
> **教材位置**：[content/chapter-09.md](../content/chapter-09.md)

---

## 章前預測（5 分鐘）

### 這章應該回答什麼問題？

1. 什麼是軟體設計？設計有哪些層次？
2. 什麼是好的設計？如何評估設計品質？
3. 有哪些設計原則和技術？
4. 設計模式是什麼？如何應用？

### 我現在的理解是什麼？

閱讀前，我的理解：
- 設計就是畫類別圖
- SOLID 原則聽過但不太會用
- 設計模式很重要但容易過度使用

### 我遇過哪些相關痛點？

1. **程式碼難以修改**：改一個地方，壞了五個地方
2. **不知道怎麼拆分**：類別太大，不知道怎麼拆
3. **過度設計**：為了「靈活」而複雜化

---

## 本章一句話

> **好的設計是高內聚、低耦合的。設計原則（SOLID）和設計模式是工具，目的是讓程式碼更容易理解、修改、測試。**

---

## 3 個關鍵概念

### 概念 1：內聚性與耦合性

**書中定義**：

- **內聚性（Cohesion）**：模組內部的相關程度。高內聚 = 好。
- **耦合性（Coupling）**：模組之間的依賴程度。低耦合 = 好。

**我的理解**：

這兩個指標解釋了為什麼有些程式碼「很難改」。

| 問題 | 原因 |
|------|------|
| 改一個地方壞五個地方 | 耦合太高 |
| 不知道這個類別在做什麼 | 內聚太低 |
| 這個函數 500 行 | 內聚太低 |
| 這個模組依賴 20 個其他模組 | 耦合太高 |

**檢驗方式**：

- 內聚性：「這個類別/模組可以用一句話描述嗎？」
- 耦合性：「改這個類別，需要改幾個其他地方？」

**經驗法則**：
- 一個類別最多 200-300 行
- 一個函數最多 20-30 行
- import 太多是警訊

---

### 概念 2：SOLID 原則

**書中定義**：

| 原則 | 說明 |
|------|------|
| S - 單一責任 | 一個類別只有一個改變的理由 |
| O - 開放/關閉 | 對擴展開放，對修改關閉 |
| L - 里氏替換 | 子類別可以替代父類別 |
| I - 介面隔離 | 多個專用介面優於一個通用介面 |
| D - 依賴反轉 | 依賴抽象，不依賴具體 |

**我的理解**：

我最常用的三個：

**1. 單一責任（S）**：最基本也最重要
- 問：「這個類別為什麼會改變？」
- 如果有多個原因，就該拆分

**2. 開放/關閉（O）**：避免 switch/if-else 爆炸
- 加新功能時，應該加新程式碼，不是改舊程式碼
- 用多型取代 switch

**3. 依賴反轉（D）**：可測試性的關鍵
- 依賴介面，不依賴具體類別
- 依賴可以注入，方便測試

**經驗**：
- L 和 I 比較進階，先掌握 S、O、D
- 不要為了 SOLID 而 SOLID，要解決實際問題

---

### 概念 3：設計模式是工具，不是目標

**書中定義**：

設計模式是對常見問題的可重用解決方案。

分類：
- 創建型：物件如何建立（Factory, Builder）
- 結構型：物件如何組合（Adapter, Decorator）
- 行為型：物件如何互動（Strategy, Observer）

**我的理解**：

設計模式的正確用法：

1. **先有問題，再找模式**
   - ❌ 「這裡可以用 Factory」
   - ✅ 「這裡建立物件的邏輯很複雜，Factory 可以幫忙」

2. **模式是溝通詞彙**
   - 說「這是 Observer 模式」比解釋整個結構快

3. **不要過度使用**
   - 簡單問題不需要複雜模式
   - 模式有成本（複雜度、間接性）

**我最常用的模式**：
- Strategy：動態切換演算法
- Factory：建立物件邏輯複雜時
- Observer：事件處理
- Decorator：動態添加功能

---

## 原則、方法、護欄

### 設計原則速查表

| 原則 | 適用情境 | 一句話 |
|------|----------|--------|
| 高內聚 | 設計模組時 | 一個模組只做一件事 |
| 低耦合 | 設計模組間關係時 | 模組之間依賴越少越好 |
| SRP | 類別設計 | 一個改變的理由 |
| OCP | 需要擴展時 | 加新程式碼，不改舊程式碼 |
| DIP | 設計依賴時 | 依賴抽象，不依賴具體 |
| 封裝 | 保護資料時 | 隱藏內部，只暴露介面 |
| 資訊隱藏 | 設計介面時 | 隱藏實作決策 |

---

### 護欄（Guardrail）

| 危險信號 | 可能的問題 | 修正方式 |
|----------|-----------|----------|
| 類別超過 500 行 | 內聚太低 | 拆分責任 |
| 函數超過 50 行 | 做太多事 | 提取函數 |
| import 超過 10 個 | 耦合太高 | 重新設計依賴 |
| 改一處壞五處 | 耦合太高 | 抽取介面、減少依賴 |
| 到處都是 switch | 違反 OCP | 用多型重構 |
| 難以寫單元測試 | 依賴太多具體類別 | 依賴注入、用介面 |
| 用了 5 個設計模式 | 過度設計 | 簡化，只在需要時用 |

---

## 1 個決策點

### 決策情境

**什麼時候該用設計模式？**

### 決策流程

```
遇到問題
│
├─ 問題簡單嗎？
│   └─ 是 → 直接解決，不需要模式
│
├─ 這個問題常見嗎？
│   ├─ 是 → 可能有適用的模式
│   └─ 否 → 直接解決
│
├─ 模式的成本值得嗎？
│   ├─ 增加的複雜度 vs 解決的問題
│   └─ 團隊熟悉這個模式嗎？
│
└─ 決定
    ├─ 成本划算 → 使用模式
    └─ 成本太高 → 簡單解決
```

### 經驗法則

**適合用模式**：
- 問題會重複出現
- 需要靈活性（會擴展）
- 團隊熟悉該模式

**不適合用模式**：
- 問題只出現一次
- 簡單問題
- 團隊不熟悉

---

## 1 個反模式（Anti-pattern）

### 反模式名稱

**「模式狂熱」症候群**（Pattern-itis）

### 錯誤做法

到處使用設計模式，不管是否需要：
- 所有物件建立都用 Factory
- 所有功能都用 Strategy
- 加一層又一層的抽象
- 「這裡可以用 XX 模式」

### 後果

1. **過度複雜**：簡單功能變得難以理解
2. **間接性過高**：找一個類別要經過五層
3. **維護困難**：改一個功能要改很多地方
4. **新人無法上手**：程式碼太「設計」了

### 正確做法

1. **問題驅動**：先有問題，再考慮模式
2. **簡單優先**：能簡單就簡單
3. **重構引入**：先寫簡單版，需要時再重構成模式
4. **成本效益**：模式有成本，要值得

**經驗法則**：
> 「先讓它工作，再讓它正確，最後讓它快。」
> 「不要為了假設的未來需求而設計。」

---

## 可落地 Checklist（至少 5 條）

設計時用這份清單：

- [x] **單一責任**：這個類別只有一個改變的理由嗎？
- [x] **高內聚**：可以用一句話描述這個模組嗎？
- [x] **低耦合**：這個模組依賴幾個其他模組？
- [x] **封裝良好**：內部資料有保護嗎？
- [x] **可測試**：可以寫單元測試嗎？依賴可以 mock 嗎？
- [x] **簡單**：這是最簡單的解決方案嗎？
- [x] **模式合理**：用的設計模式真的需要嗎？

---

## 章後練習

### 練習：評估一段程式碼的設計品質

> 目標：找出設計問題並提出改善建議

**原始程式碼**（偽代碼）：

```python
class UserService:
    def __init__(self):
        self.db = MySQL()  # 直接依賴具體類別
        self.email = SMTP() # 直接依賴具體類別

    def register(self, name, email, password):
        # 驗證
        if not name or len(name) < 2:
            raise Error("名稱太短")
        if "@" not in email:
            raise Error("email 格式錯誤")
        if len(password) < 8:
            raise Error("密碼太短")

        # 儲存
        user_id = self.db.insert("users", {
            "name": name,
            "email": email,
            "password": hash(password)
        })

        # 寄信
        self.email.send(
            to=email,
            subject="歡迎加入",
            body=f"Hi {name}..."
        )

        # 記錄日誌
        log(f"User {user_id} registered")

        return user_id
```

**問題分析**：

| 問題 | 違反的原則 |
|------|-----------|
| 直接依賴 MySQL、SMTP | DIP（依賴反轉） |
| register 做太多事 | SRP（單一責任） |
| 驗證、儲存、寄信、記錄混在一起 | 內聚性低 |
| 無法單元測試 | 依賴具體類別 |

**改善建議**：

```python
class UserService:
    def __init__(self, user_repo, email_service, logger):
        self.user_repo = user_repo    # 依賴注入
        self.email = email_service    # 依賴介面
        self.logger = logger

    def register(self, user_data):
        user = User.create(user_data)  # User 負責驗證
        self.user_repo.save(user)
        self.email.send_welcome(user)
        self.logger.log(f"User {user.id} registered")
        return user.id

class User:
    @staticmethod
    def create(data):
        # 驗證邏輯移到 User
        if not data.name or len(data.name) < 2:
            raise ValidationError("名稱太短")
        # ...
        return User(data)
```

**改善後**：
- 依賴注入，可測試
- 責任分離（User 負責驗證）
- 內聚性提高

---

## 延伸思考

### 你的程式碼中，內聚性和耦合性的問題在哪裡？

**我的反思**：

常見問題：

1. **Service 類別太大**
   - 一個 UserService 500+ 行
   - 解法：按功能拆分（UserRegistrationService、UserQueryService）

2. **直接依賴具體類別**
   - 直接 new MySQL()
   - 解法：依賴注入

3. **缺少介面**
   - 類別直接互相調用
   - 解法：定義介面，依賴介面

### SOLID 中你最難應用的是哪個？

**我的思考**：

最難的是 **開放/關閉原則（OCP）**。

困難在於：
1. 需要預見未來的擴展點
2. 過度應用會導致過度設計
3. 不知道什麼時候該用

**我的策略**：
1. 第一次寫簡單版
2. 需要第二種變體時，考慮重構
3. 「Rule of Three」：三次才抽象

---

## 完成確認

- [x] 完成章前預測
- [x] 讀完本章
- [x] 填寫本章一句話
- [x] 填寫 3 個關鍵概念
- [x] 填寫原則、方法、護欄
- [x] 填寫 1 個決策點
- [x] 填寫 1 個反模式
- [x] 填寫 Checklist
- [x] 完成章後練習
- [x] 完成延伸思考

**完成日期**：2025-12-27
