# 第22章　軟體組態管理 — 學習筆記

> **狀態**：✅ 已完成
> **閱讀日期**：2025-12-27
> **教材位置**：[content/chapter-22.md](../content/chapter-22.md)

---

## 章前預測（5 分鐘）

### 這章應該回答什麼問題？

1. 組態管理包含哪些面向？
2. 分支策略怎麼選？
3. 如何做可重現的建構？
4. 配置和機密怎麼管理？

### 我現在的理解是什麼？

閱讀前，我的理解：
- 組態管理 = Git
- 分支策略用 Git Flow 就對了
- 配置放 .env 檔

### 我遇過哪些相關痛點？

1. **分支混亂**：不知道哪個分支是什麼
2. **無法重現舊版本**：「這個版本怎麼 build 的？」
3. **機密外洩**：API Key 進了 Git

---

## 本章一句話

> **組態管理確保每個版本都可識別、可追蹤、可重現。使用適合團隊的分支策略，確保建構可重現，配置外部化並安全管理機密。**

---

## 3 個關鍵概念

### 概念 1：分支策略選擇

**書中定義**：

| 策略 | 特點 |
|------|------|
| Git Flow | 完整，適合定期發布 |
| GitHub Flow | 簡單，適合持續部署 |

**我的理解**：

選策略要看發布頻率：

| 發布頻率 | 建議策略 |
|----------|----------|
| 每天/每週 | GitHub Flow |
| 每月 | Git Flow |
| 多版本維護 | Git Flow |

**我的選擇**：GitHub Flow

原因：
- 持續部署
- 團隊小
- 只維護一個版本

**經驗法則**：
> 「如果你能持續部署，用最簡單的策略。」

---

### 概念 2：可重現建構

**書中定義**：

任何版本都能重新建構出相同的結果。

| 要素 | 做法 |
|------|------|
| 原始碼 | 版本控制、標籤 |
| 依賴 | 鎖定版本 |
| 環境 | 容器化 |
| 建構腳本 | 版本控制 |

**我的理解**：

「三個月前那個版本怎麼 build？」

**以前**：「呃...我不知道...」
**現在**：`git checkout v1.2.3 && docker build .`

**我的實踐**：

```dockerfile
# 鎖定基礎映像版本
FROM node:18.17.0-alpine

# 鎖定依賴版本
COPY package-lock.json ./
RUN npm ci
```

```json
// package-lock.json 進版控
```

**經驗法則**：
> 「如果不在版控裡，就不存在。」

---

### 概念 3：配置管理三原則

**書中定義**：

1. **外部化**：配置不進程式碼
2. **環境變數**：用環境變數注入
3. **機密分離**：機密用專門工具管理

**我的理解**：

**配置分層**：

| 層次 | 範例 | 版控？ |
|------|------|--------|
| 預設值 | 程式碼裡的預設 | ✅ |
| 共用配置 | config.yaml | ✅ |
| 環境配置 | config.prod.yaml | ✅ |
| 機密 | API Key, 密碼 | ❌ |

**機密管理**：

| 方式 | 適用 |
|------|------|
| 環境變數 | 簡單場景 |
| AWS Secrets Manager | AWS 環境 |
| HashiCorp Vault | 企業級 |
| Kubernetes Secrets | K8s 環境 |

**經驗法則**：
> 「機密絕不進版控。」

---

## 原則、方法、護欄

### 組態管理速查表

| 面向 | 工具 | 做法 |
|------|------|------|
| 版本控制 | Git | 所有東西進版控 |
| 分支 | GitHub Flow | main + feature |
| 建構 | Docker | 容器化 |
| CI/CD | GitHub Actions | 自動化 |
| 配置 | 環境變數 | 外部化 |
| 機密 | Vault/Secrets | 專門管理 |

---

### 護欄（Guardrail）

| 危險信號 | 可能的問題 | 修正方式 |
|----------|-----------|----------|
| 機密在程式碼 | 外洩風險 | 移到機密管理 |
| 無法重建舊版 | 建構不可重現 | 鎖定依賴、容器化 |
| 分支太多 | 管理混亂 | 簡化策略 |
| 沒有版本標籤 | 不知道在跑什麼 | 建立標籤規範 |
| 手動部署 | 易出錯 | 自動化 |

---

## 1 個決策點

### 決策情境

**Git Flow vs. GitHub Flow？**

### 選項對比

| 面向 | Git Flow | GitHub Flow |
|------|----------|-------------|
| 複雜度 | 高 | 低 |
| 發布頻率 | 低（週/月） | 高（天） |
| 多版本 | 支援 | 不支援 |
| 學習曲線 | 高 | 低 |

### 決策準則

| 選 Git Flow | 選 GitHub Flow |
|-------------|----------------|
| 定期發布 | 持續部署 |
| 維護多版本 | 只維護最新 |
| 大團隊 | 小團隊 |
| 嚴格審批 | 快速迭代 |

**我的選擇**：
> 「先從 GitHub Flow 開始，真的需要再改 Git Flow。」

---

## 1 個反模式（Anti-pattern）

### 反模式名稱

**「機密進版控」症候群**

### 錯誤做法

把敏感資料放進 Git：
- API Key 在程式碼裡
- 密碼在 config.yaml
- .env 檔進了 Git

### 後果

1. **外洩風險**：歷史記錄永遠存在
2. **無法撤銷**：即使刪除，clone 的人都有
3. **合規問題**：違反安全政策
4. **被濫用**：GitHub 有機器人掃描

### 正確做法

1. **機密不進版控**
   - 加入 .gitignore
   - 使用 .env.example

2. **使用機密管理工具**
   - 環境變數
   - Secrets Manager
   - Vault

3. **偵測機密**
   - pre-commit hook
   - git-secrets

```bash
# .gitignore
.env
*.key
*.pem
```

```bash
# pre-commit hook
git secrets --scan
```

**檢驗標準**：
> 「如果 repo 公開，會有問題嗎？」

---

## 可落地 Checklist（至少 5 條）

組態管理檢查：

- [x] **版本控制**：所有程式碼都在 Git 嗎？
- [x] **分支策略**：有明確的策略嗎？
- [x] **依賴鎖定**：package-lock.json 進版控嗎？
- [x] **容器化**：用 Docker 嗎？
- [x] **配置分離**：配置和程式碼分離嗎？
- [x] **機密管理**：機密沒有進版控嗎？
- [x] **版本標籤**：發布有標籤嗎？
- [x] **可重現**：能重建舊版本嗎？

---

## 章後練習

### 練習：檢視你的組態管理

> 目標：評估目前的組態管理狀況

**自我評估**：

| 面向 | 現狀 | 目標 | 改善 |
|------|------|------|------|
| 版本控制 | ✅ Git | - | - |
| 分支策略 | ⚠️ 沒有明確規範 | 明確策略 | 制定規範 |
| 依賴鎖定 | ✅ package-lock | - | - |
| 容器化 | ⚠️ 部分 | 全部 | 完成容器化 |
| 配置分離 | ⚠️ 部分硬編碼 | 完全分離 | 外部化 |
| 機密管理 | ⚠️ .env 在版控 | 安全管理 | 移到 Secrets |
| 版本標籤 | ❌ 沒有 | 有標籤 | 建立規範 |

**改善計畫**：

1. **本週**：
   - 把 .env 移出版控
   - 建立 .env.example

2. **下週**：
   - 完成 Docker 化
   - 建立 Dockerfile

3. **本月**：
   - 制定分支策略
   - 建立版本標籤規範

---

## 延伸思考

### 如何處理已經進版控的機密？

**步驟**：

1. **立即撤銷**
   - 換掉所有外洩的金鑰
   - 密碼全部重設

2. **清除歷史**
   - git filter-branch
   - BFG Repo-Cleaner

3. **預防未來**
   - 加入 .gitignore
   - pre-commit hook
   - 教育團隊

**範例**：

```bash
# 用 BFG 清除敏感檔案
bfg --delete-files .env repo.git

# 強制更新遠端
git push --force
```

**經驗教訓**：
> 「預防比清除容易一萬倍。」

### 如何選擇語義版本號？

**我的規則**：

| 變更類型 | 版本更新 | 範例 |
|----------|----------|------|
| 不相容 API 變更 | MAJOR | 1.0.0 → 2.0.0 |
| 新功能（相容） | MINOR | 1.0.0 → 1.1.0 |
| Bug 修復 | PATCH | 1.0.0 → 1.0.1 |

**自動化**：

```bash
# 用 conventional commits
feat: 新功能 → MINOR
fix: 修復 → PATCH
feat!: 破壞性變更 → MAJOR
```

---

## 完成確認

- [x] 完成章前預測
- [x] 讀完本章
- [x] 填寫本章一句話
- [x] 填寫 3 個關鍵概念
- [x] 填寫原則、方法、護欄
- [x] 填寫 1 個決策點
- [x] 填寫 1 個反模式
- [x] 填寫 Checklist
- [x] 完成章後練習
- [x] 完成延伸思考

**完成日期**：2025-12-27
