# 第14章　以樣式（Pattern）為基礎的設計 — 學習筆記

> **狀態**：✅ 已完成
> **閱讀日期**：2025-12-27
> **教材位置**：[content/chapter-14.md](../content/chapter-14.md)

---

## 章前預測（5 分鐘）

### 這章應該回答什麼問題？

1. 什麼是設計模式？為什麼有用？
2. 常用的設計模式有哪些？
3. 什麼時候該用模式？什麼時候不該用？
4. 如何重構到模式？

### 我現在的理解是什麼？

閱讀前，我的理解：
- 設計模式很重要，應該多用
- GoF 的 23 個模式都要會
- 用模式 = 好設計

### 我遇過哪些相關痛點？

1. **不知道什麼時候用**：知道模式但不知道何時用
2. **過度使用**：用了模式反而更複雜
3. **團隊不熟悉**：用了模式但別人看不懂

---

## 本章一句話

> **設計模式是工具，不是目標。先解決問題，需要時才用模式。最好的時機是重構時引入，而非一開始就用。**

---

## 3 個關鍵概念

### 概念 1：模式是溝通工具

**書中定義**：

模式的價值：
- 溝通：共同詞彙，快速表達設計意圖
- 經驗：站在前人的經驗上
- 品質：經過驗證的解決方案

**我的理解**：

模式最大的價值是**溝通**，不是技術本身。

**例子**：

```
❌ 不用模式溝通
「我們有一個 NotificationFactory 類別，
它有一個 create 方法，根據 type 參數
返回不同的 Notification 子類別...」

✅ 用模式溝通
「這裡用 Factory Method 模式。」
```

**前提**：團隊都懂這個模式。否則反而增加溝通成本。

---

### 概念 2：常用模式快速指南

**書中定義**：

| 需要 | 模式 |
|------|------|
| 建立複雜物件 | Builder |
| 動態切換演算法 | Strategy |
| 一對多通知 | Observer |
| 介面轉換 | Adapter |
| 動態添加功能 | Decorator |
| 簡化複雜系統 | Facade |

**我的理解**：

我最常用的 5 個模式：

| 模式 | 我的使用場景 |
|------|-------------|
| **Strategy** | 多種演算法、多種驗證規則 |
| **Factory** | 根據條件建立不同物件 |
| **Observer** | 事件處理、狀態變更通知 |
| **Decorator** | 添加日誌、快取、權限 |
| **Repository** | 資料存取隔離 |

**選擇技巧**：

```
if 需要建立不同類型物件:
    → Factory
elif 需要動態切換行為:
    → Strategy
elif 需要一對多通知:
    → Observer
elif 需要動態添加功能:
    → Decorator
elif 需要轉換介面:
    → Adapter
elif 需要簡化複雜 API:
    → Facade
```

---

### 概念 3：重構到模式

**書中定義**：

最佳實踐：
1. 先簡單實作
2. 發現需要變化
3. 重構到模式

不要一開始就用模式。

**我的理解**：

這是我最大的學習：**先讓它工作，再重構**。

**實際流程**：

```
第一版：直接 if-else
    │
    ├─ 變化 1 → 加一個 elif
    │
    ├─ 變化 2 → 再加一個 elif
    │
    ├─ 變化 3 → 「這裡開始難維護了」
    │
    ▼
重構到 Strategy 模式
```

**Rule of Three**：
- 第一次：直接寫
- 第二次：複製修改
- 第三次：重構/用模式

---

## 原則、方法、護欄

### 模式選擇速查表

| 問題 | 模式 | 一句話 |
|------|------|--------|
| 建立邏輯複雜 | Factory | 隱藏建立邏輯 |
| 物件很複雜 | Builder | 分步驟建立 |
| 演算法需切換 | Strategy | 策略可替換 |
| 需要通知多方 | Observer | 發布訂閱 |
| 需要添加功能 | Decorator | 包裝添加 |
| 介面不相容 | Adapter | 轉換介面 |
| API 太複雜 | Facade | 簡化介面 |
| 隔離資料存取 | Repository | 抽象資料來源 |

---

### 護欄（Guardrail）

| 危險信號 | 可能的問題 | 修正方式 |
|----------|-----------|----------|
| 一開始就用模式 | 過早設計 | 先簡單實作 |
| 到處都是模式 | 過度使用 | 只在需要時用 |
| 團隊看不懂 | 溝通失敗 | 培訓或簡化 |
| 模式比問題複雜 | 殺雞用牛刀 | 簡單解決 |
| 強迫套用模式 | 教條式 | 調整適應 |

---

## 1 個決策點

### 決策情境

**什麼時候該引入設計模式？**

### 決策流程

```
遇到設計問題
│
├─ 問題簡單？
│   └─ 是 → 直接解決，不用模式
│
├─ 問題第一次遇到？
│   └─ 是 → 簡單實作，觀察變化
│
├─ 第二次遇到？
│   └─ 可以忍受 → 繼續觀察
│
├─ 第三次遇到？
│   └─ 考慮引入模式
│
├─ 團隊熟悉這個模式？
│   ├─ 是 → 使用模式
│   └─ 否 → 培訓或用更簡單的方式
│
└─ 結果
```

---

## 1 個反模式（Anti-pattern）

### 反模式名稱

**「模式狂熱」症候群**（Pattern-itis）

### 錯誤做法

到處使用設計模式：
- 所有物件都用 Factory
- 所有操作都用 Command
- 每個類別都是 Singleton
- 「這裡可以用 XX 模式！」

### 後果

1. **過度複雜**：簡單問題變複雜
2. **難以理解**：層層包裝
3. **難以維護**：改一個地方要改很多
4. **浪費時間**：設計模式不等於好設計

### 正確做法

1. **問題驅動**：先有問題，再考慮模式
2. **簡單優先**：最簡單的解決方案
3. **重構引入**：需要時再加
4. **成本效益**：模式有成本

**經驗法則**：
> 「如果你不確定要不要用模式，那就不要用。」
> 「先讓它工作，再讓它正確，最後讓它快。」

---

## 可落地 Checklist（至少 5 條）

使用設計模式前用這份清單：

- [x] **問題清楚**：我要解決什麼問題？
- [x] **模式匹配**：這個模式適合這個問題嗎？
- [x] **團隊熟悉**：團隊成員懂這個模式嗎？
- [x] **成本合理**：增加的複雜度值得嗎？
- [x] **時機正確**：是不是可以先簡單做？
- [x] **可以重構**：之後如果不需要，容易移除嗎？

---

## 章後練習

### 練習：識別適合的模式

> 情境：支付系統需要支援多種支付方式

**問題分析**：
- 目前有：信用卡、轉帳
- 之後會加：Apple Pay、Google Pay、Line Pay
- 每種支付方式有不同的處理邏輯

**適合的模式**：**Strategy**

**原因**：
- 多種演算法（支付方式）
- 需要動態切換
- 未來會擴展

**簡單實作**：

```python
class PaymentStrategy:
    def pay(self, amount: Money) -> Result:
        raise NotImplementedError

class CreditCardPayment(PaymentStrategy):
    def pay(self, amount: Money) -> Result:
        # 信用卡邏輯
        pass

class BankTransferPayment(PaymentStrategy):
    def pay(self, amount: Money) -> Result:
        # 轉帳邏輯
        pass

class PaymentService:
    def __init__(self, strategy: PaymentStrategy):
        self.strategy = strategy

    def process(self, amount: Money):
        return self.strategy.pay(amount)
```

**好處**：
- 加新支付方式只需加新 Strategy
- 不用改 PaymentService
- 容易測試每個 Strategy

---

## 延伸思考

### 如何在團隊中推廣設計模式？

**我的策略**：

1. **從實際問題出發**
   - 先遇到問題，再介紹模式
   - 不是為了用模式而用

2. **Code Review 中教學**
   - 看到可以用模式的地方，提出建議
   - 解釋為什麼這裡適合

3. **建立模式詞彙表**
   - 團隊共同語言
   - 「這裡可以用 Strategy」

4. **重構練習**
   - 找現有程式碼
   - 練習「重構到模式」

### 設計模式會過時嗎？

**我的看法**：

模式的「形式」可能變，但「本質」不變。

| 變化 | 不變 |
|------|------|
| 語言語法 | 問題本質 |
| 框架實現 | 解決思路 |
| 命名方式 | 設計原則 |

函數式程式設計興起後，一些模式用更簡潔的方式實現，但問題和解法的本質沒變。

---

## Part 2 完成回顧

### Part 2 完成的章節

| 章節 | 主題 | 核心概念 |
|------|------|----------|
| 第6章 | 原則 | KISS, DRY, Separation of Concerns |
| 第7章 | 需求工程 | 需求層次、使用者故事 |
| 第8章 | 需求建模 | UML 圖表選擇 |
| 第9章 | 設計概念 | 內聚、耦合、SOLID |
| 第10章 | 架構設計 | 架構風格、ADR |
| 第11章 | 元件設計 | 元件原則、通訊 |
| 第12章 | UX 設計 | 認知負擔、可及性 |
| 第13章 | 行動設計 | 觸控優先、離線優先 |
| 第14章 | 設計模式 | GoF 模式、重構到模式 |

### Part 2 的核心學習

1. **需求是根本**：需求不清楚，設計再好也沒用
2. **架構決定品質**：架構決策難以改變
3. **設計要平衡**：簡單 vs 靈活
4. **模式是工具**：不是目標

---

## 完成確認

- [x] 完成章前預測
- [x] 讀完本章
- [x] 填寫本章一句話
- [x] 填寫 3 個關鍵概念
- [x] 填寫原則、方法、護欄
- [x] 填寫 1 個決策點
- [x] 填寫 1 個反模式
- [x] 填寫 Checklist
- [x] 完成章後練習
- [x] 完成延伸思考

**完成日期**：2025-12-27

---

**🎉 Part 2 建模 完成！**
